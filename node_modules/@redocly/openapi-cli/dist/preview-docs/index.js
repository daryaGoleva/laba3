"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = startPreviewServer;

var _handlebars = require("handlebars");

var _chalk = _interopRequireDefault(require("chalk"));

var portfinder = _interopRequireWildcard(require("portfinder"));

var _fs = require("fs");

var path = _interopRequireWildcard(require("path"));

var _server = require("./server");

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// import { watch } from 'chokidar';
function getPageHTML(htmlTemplate, redocOptions = {}, useRedocPro, wsPort) {
  let templateSrc = (0, _fs.readFileSync)(htmlTemplate, 'utf-8'); // fix template for backward compatibility

  templateSrc = templateSrc.replace(/{?{{redocHead}}}?/, '{{{redocHead}}}').replace('{{redocBody}}', '{{{redocHTML}}}');
  const template = (0, _handlebars.compile)(templateSrc);
  return template({
    redocHead: `
  <script>
    window.__REDOC_EXPORT = '${useRedocPro ? 'RedoclyReferenceDocs' : 'Redoc'}';
    window.__OPENAPI_CLI_WS_PORT = ${wsPort};
  </script>
  <script src="/simplewebsocket.min.js"></script>
  <script src="/hot.js"></script>
  <script src="${useRedocPro ? 'https://cdn.jsdelivr.net/npm/@redocly/reference-docs@latest/dist/redocly-reference-docs.min.js' : 'https://cdn.jsdelivr.net/npm/redoc@latest/bundles/redoc.standalone.js'}"></script>
`,
    redocHTML: `
  <div id="redoc"></div>
  <script>
    var container = document.getElementById('redoc');
    ${useRedocPro ? "window[window.__REDOC_EXPORT].setPublicPath('https://cdn.jsdelivr.net/npm/@redocly/reference-docs@latest/dist/');" : ''}
    window[window.__REDOC_EXPORT].init("openapi.json", ${JSON.stringify(redocOptions)}, container)
  </script>`
  });
}

async function startPreviewServer(port, {
  getBundle,
  getOptions,
  useRedocPro
}) {
  const defaultTemplate = path.join(__dirname, 'default.hbs');

  const handler = async (request, response) => {
    console.time(_chalk.default.dim(`GET ${request.url}`));
    const {
      htmlTemplate
    } = getOptions() || {};

    if (request.url === '/') {
      (0, _server.respondWithGzip)(getPageHTML(htmlTemplate || defaultTemplate, getOptions(), useRedocPro, wsPort), request, response, {
        'Content-Type': 'text/html'
      });
    } else if (request.url === '/openapi.json') {
      (0, _server.respondWithGzip)(JSON.stringify((await getBundle())), request, response, {
        'Content-Type': 'application/json'
      });
    } else {
      const filePath = {
        '/hot.js': path.join(__dirname, 'hot.js'),
        '/simplewebsocket.min.js': require.resolve('simple-websocket/simplewebsocket.min.js')
      }[request.url] || path.resolve(htmlTemplate ? path.dirname(htmlTemplate) : process.cwd(), `.${request.url}`);
      const extname = String(path.extname(filePath)).toLowerCase();
      const contentType = _server.mimeTypes[extname] || 'application/octet-stream';

      try {
        (0, _server.respondWithGzip)((await _fs.promises.readFile(filePath)), request, response, {
          'Content-Type': contentType
        });
      } catch (e) {
        if (e.code === 'ENOENT') {
          (0, _server.respondWithGzip)('404 Not Found', request, response, {
            'Content-Type': 'text/html'
          }, 404);
        } else {
          (0, _server.respondWithGzip)(`Something went wrong: ${e.code || e.message}...\n`, request, response, {}, 500);
        }
      }
    }

    console.timeEnd(_chalk.default.dim(`GET ${request.url}`));
  };

  let wsPort = await portfinder.getPortPromise({
    port: 32201
  });
  const server = (0, _server.startHttpServer)(port, handler);
  server.on('listening', () => {
    process.stdout.write(`\n  ðŸ”Ž  Preview server running at ${_chalk.default.blue(`http://127.0.0.1:${port}\n`)}`);
  });
  return (0, _server.startWsServer)(wsPort);
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9wcmV2aWV3LWRvY3MvaW5kZXguanMiXSwibmFtZXMiOlsiZ2V0UGFnZUhUTUwiLCJodG1sVGVtcGxhdGUiLCJyZWRvY09wdGlvbnMiLCJ1c2VSZWRvY1BybyIsIndzUG9ydCIsInRlbXBsYXRlU3JjIiwicmVwbGFjZSIsInRlbXBsYXRlIiwicmVkb2NIZWFkIiwicmVkb2NIVE1MIiwiSlNPTiIsInN0cmluZ2lmeSIsInN0YXJ0UHJldmlld1NlcnZlciIsInBvcnQiLCJnZXRCdW5kbGUiLCJnZXRPcHRpb25zIiwiZGVmYXVsdFRlbXBsYXRlIiwicGF0aCIsImpvaW4iLCJfX2Rpcm5hbWUiLCJoYW5kbGVyIiwicmVxdWVzdCIsInJlc3BvbnNlIiwiY29uc29sZSIsInRpbWUiLCJjaGFsayIsImRpbSIsInVybCIsImZpbGVQYXRoIiwicmVxdWlyZSIsInJlc29sdmUiLCJkaXJuYW1lIiwicHJvY2VzcyIsImN3ZCIsImV4dG5hbWUiLCJTdHJpbmciLCJ0b0xvd2VyQ2FzZSIsImNvbnRlbnRUeXBlIiwibWltZVR5cGVzIiwiZnNQcm9taXNlcyIsInJlYWRGaWxlIiwiZSIsImNvZGUiLCJtZXNzYWdlIiwidGltZUVuZCIsInBvcnRmaW5kZXIiLCJnZXRQb3J0UHJvbWlzZSIsInNlcnZlciIsIm9uIiwic3Rkb3V0Iiwid3JpdGUiLCJibHVlIl0sIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBR0E7O0FBQ0E7O0FBRUE7Ozs7Ozs7O0FBVEE7QUFhQSxTQUFTQSxXQUFULENBQXFCQyxZQUFyQixFQUFtQ0MsWUFBWSxHQUFHLEVBQWxELEVBQXNEQyxXQUF0RCxFQUFtRUMsTUFBbkUsRUFBMkU7QUFDekUsTUFBSUMsV0FBVyxHQUFHLHNCQUFhSixZQUFiLEVBQTJCLE9BQTNCLENBQWxCLENBRHlFLENBR3pFOztBQUNBSSxFQUFBQSxXQUFXLEdBQUdBLFdBQVcsQ0FDdEJDLE9BRFcsQ0FDSCxtQkFERyxFQUNrQixpQkFEbEIsRUFFWEEsT0FGVyxDQUVILGVBRkcsRUFFYyxpQkFGZCxDQUFkO0FBSUEsUUFBTUMsUUFBUSxHQUFHLHlCQUFRRixXQUFSLENBQWpCO0FBRUEsU0FBT0UsUUFBUSxDQUFDO0FBQ2RDLElBQUFBLFNBQVMsRUFBRzs7K0JBRWVMLFdBQVcsR0FBRyxzQkFBSCxHQUE0QixPQUFRO3FDQUN6Q0MsTUFBTzs7OztpQkFJM0JELFdBQVcsR0FDdEIsZ0dBRHNCLEdBRXRCLHVFQUF3RTtDQVY1RDtBQVlkTSxJQUFBQSxTQUFTLEVBQUc7Ozs7TUFJVk4sV0FBVyxHQUFHLG1IQUFILEdBQXlILEVBQUc7eURBQ3BGTyxJQUFJLENBQUNDLFNBQUwsQ0FBZVQsWUFBZixDQUE2Qjs7QUFqQnBFLEdBQUQsQ0FBZjtBQW9CRDs7QUFFYyxlQUFlVSxrQkFBZixDQUFrQ0MsSUFBbEMsRUFBd0M7QUFDckRDLEVBQUFBLFNBRHFEO0FBRXJEQyxFQUFBQSxVQUZxRDtBQUdyRFosRUFBQUE7QUFIcUQsQ0FBeEMsRUFJWjtBQUNELFFBQU1hLGVBQWUsR0FBR0MsSUFBSSxDQUFDQyxJQUFMLENBQVVDLFNBQVYsRUFBcUIsYUFBckIsQ0FBeEI7O0FBQ0EsUUFBTUMsT0FBTyxHQUFHLE9BQU9DLE9BQVAsRUFBZ0JDLFFBQWhCLEtBQTZCO0FBQzNDQyxJQUFBQSxPQUFPLENBQUNDLElBQVIsQ0FBYUMsZUFBTUMsR0FBTixDQUFXLE9BQU1MLE9BQU8sQ0FBQ00sR0FBSSxFQUE3QixDQUFiO0FBQ0EsVUFBTTtBQUFFMUIsTUFBQUE7QUFBRixRQUFtQmMsVUFBVSxNQUFNLEVBQXpDOztBQUVBLFFBQUlNLE9BQU8sQ0FBQ00sR0FBUixLQUFnQixHQUFwQixFQUF5QjtBQUN2QixtQ0FBZ0IzQixXQUFXLENBQUNDLFlBQVksSUFBSWUsZUFBakIsRUFBa0NELFVBQVUsRUFBNUMsRUFBZ0RaLFdBQWhELEVBQTZEQyxNQUE3RCxDQUEzQixFQUFpR2lCLE9BQWpHLEVBQTBHQyxRQUExRyxFQUFvSDtBQUNsSCx3QkFBZ0I7QUFEa0csT0FBcEg7QUFHRCxLQUpELE1BSU8sSUFBSUQsT0FBTyxDQUFDTSxHQUFSLEtBQWdCLGVBQXBCLEVBQXFDO0FBQzFDLG1DQUFnQmpCLElBQUksQ0FBQ0MsU0FBTCxFQUFlLE1BQU1HLFNBQVMsRUFBOUIsRUFBaEIsRUFBbURPLE9BQW5ELEVBQTREQyxRQUE1RCxFQUFzRTtBQUNwRSx3QkFBZ0I7QUFEb0QsT0FBdEU7QUFHRCxLQUpNLE1BSUE7QUFDTCxZQUFNTSxRQUFRLEdBQUc7QUFDZixtQkFBV1gsSUFBSSxDQUFDQyxJQUFMLENBQVVDLFNBQVYsRUFBcUIsUUFBckIsQ0FESTtBQUVmLG1DQUEyQlUsT0FBTyxDQUFDQyxPQUFSLENBQWdCLHlDQUFoQjtBQUZaLFFBR2ZULE9BQU8sQ0FBQ00sR0FITyxLQUdDVixJQUFJLENBQUNhLE9BQUwsQ0FBYTdCLFlBQVksR0FBR2dCLElBQUksQ0FBQ2MsT0FBTCxDQUFhOUIsWUFBYixDQUFILEdBQWdDK0IsT0FBTyxDQUFDQyxHQUFSLEVBQXpELEVBQXlFLElBQUdaLE9BQU8sQ0FBQ00sR0FBSSxFQUF4RixDQUhsQjtBQUtBLFlBQU1PLE9BQU8sR0FBR0MsTUFBTSxDQUFDbEIsSUFBSSxDQUFDaUIsT0FBTCxDQUFhTixRQUFiLENBQUQsQ0FBTixDQUErQlEsV0FBL0IsRUFBaEI7QUFFQSxZQUFNQyxXQUFXLEdBQUdDLGtCQUFVSixPQUFWLEtBQXNCLDBCQUExQzs7QUFDQSxVQUFJO0FBQ0Ysc0NBQWdCLE1BQU1LLGFBQVdDLFFBQVgsQ0FBb0JaLFFBQXBCLENBQXRCLEdBQXFEUCxPQUFyRCxFQUE4REMsUUFBOUQsRUFBd0U7QUFDdEUsMEJBQWdCZTtBQURzRCxTQUF4RTtBQUdELE9BSkQsQ0FJRSxPQUFPSSxDQUFQLEVBQVU7QUFDVixZQUFJQSxDQUFDLENBQUNDLElBQUYsS0FBVyxRQUFmLEVBQXlCO0FBQ3ZCLHVDQUFnQixlQUFoQixFQUFpQ3JCLE9BQWpDLEVBQTBDQyxRQUExQyxFQUFvRDtBQUFFLDRCQUFnQjtBQUFsQixXQUFwRCxFQUFxRixHQUFyRjtBQUNELFNBRkQsTUFFTztBQUNMLHVDQUFpQix5QkFBd0JtQixDQUFDLENBQUNDLElBQUYsSUFBVUQsQ0FBQyxDQUFDRSxPQUFRLE9BQTdELEVBQXFFdEIsT0FBckUsRUFBOEVDLFFBQTlFLEVBQXdGLEVBQXhGLEVBQTRGLEdBQTVGO0FBQ0Q7QUFDRjtBQUNGOztBQUNEQyxJQUFBQSxPQUFPLENBQUNxQixPQUFSLENBQWdCbkIsZUFBTUMsR0FBTixDQUFXLE9BQU1MLE9BQU8sQ0FBQ00sR0FBSSxFQUE3QixDQUFoQjtBQUNELEdBbENEOztBQW9DQSxNQUFJdkIsTUFBTSxHQUFHLE1BQU15QyxVQUFVLENBQUNDLGNBQVgsQ0FBMEI7QUFBRWpDLElBQUFBLElBQUksRUFBRTtBQUFSLEdBQTFCLENBQW5CO0FBRUEsUUFBTWtDLE1BQU0sR0FBRyw2QkFBZ0JsQyxJQUFoQixFQUFzQk8sT0FBdEIsQ0FBZjtBQUNBMkIsRUFBQUEsTUFBTSxDQUFDQyxFQUFQLENBQVUsV0FBVixFQUF1QixNQUFNO0FBQzNCaEIsSUFBQUEsT0FBTyxDQUFDaUIsTUFBUixDQUFlQyxLQUFmLENBQXNCLHFDQUFvQ3pCLGVBQU0wQixJQUFOLENBQVksb0JBQW1CdEMsSUFBSyxJQUFwQyxDQUF5QyxFQUFuRztBQUNELEdBRkQ7QUFJQSxTQUFPLDJCQUFjVCxNQUFkLENBQVA7QUFDRCIsInNvdXJjZXNDb250ZW50IjpbIi8vIGltcG9ydCB7IHdhdGNoIH0gZnJvbSAnY2hva2lkYXInO1xuaW1wb3J0IHsgY29tcGlsZSB9IGZyb20gJ2hhbmRsZWJhcnMnO1xuaW1wb3J0IGNoYWxrIGZyb20gJ2NoYWxrJztcbmltcG9ydCAqIGFzIHBvcnRmaW5kZXIgZnJvbSAncG9ydGZpbmRlcic7XG5cblxuaW1wb3J0IHsgcmVhZEZpbGVTeW5jLCBwcm9taXNlcyBhcyBmc1Byb21pc2VzIH0gZnJvbSAnZnMnO1xuaW1wb3J0ICogYXMgcGF0aCBmcm9tICdwYXRoJztcblxuaW1wb3J0IHtcbiAgc3RhcnRIdHRwU2VydmVyLCBzdGFydFdzU2VydmVyLCByZXNwb25kV2l0aEd6aXAsIG1pbWVUeXBlcyxcbn0gZnJvbSAnLi9zZXJ2ZXInO1xuXG5mdW5jdGlvbiBnZXRQYWdlSFRNTChodG1sVGVtcGxhdGUsIHJlZG9jT3B0aW9ucyA9IHt9LCB1c2VSZWRvY1Bybywgd3NQb3J0KSB7XG4gIGxldCB0ZW1wbGF0ZVNyYyA9IHJlYWRGaWxlU3luYyhodG1sVGVtcGxhdGUsICd1dGYtOCcpO1xuXG4gIC8vIGZpeCB0ZW1wbGF0ZSBmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eVxuICB0ZW1wbGF0ZVNyYyA9IHRlbXBsYXRlU3JjXG4gICAgLnJlcGxhY2UoL3s/e3tyZWRvY0hlYWR9fX0/LywgJ3t7e3JlZG9jSGVhZH19fScpXG4gICAgLnJlcGxhY2UoJ3t7cmVkb2NCb2R5fX0nLCAne3t7cmVkb2NIVE1MfX19Jyk7XG5cbiAgY29uc3QgdGVtcGxhdGUgPSBjb21waWxlKHRlbXBsYXRlU3JjKTtcblxuICByZXR1cm4gdGVtcGxhdGUoe1xuICAgIHJlZG9jSGVhZDogYFxuICA8c2NyaXB0PlxuICAgIHdpbmRvdy5fX1JFRE9DX0VYUE9SVCA9ICcke3VzZVJlZG9jUHJvID8gJ1JlZG9jbHlSZWZlcmVuY2VEb2NzJyA6ICdSZWRvYyd9JztcbiAgICB3aW5kb3cuX19PUEVOQVBJX0NMSV9XU19QT1JUID0gJHt3c1BvcnR9O1xuICA8L3NjcmlwdD5cbiAgPHNjcmlwdCBzcmM9XCIvc2ltcGxld2Vic29ja2V0Lm1pbi5qc1wiPjwvc2NyaXB0PlxuICA8c2NyaXB0IHNyYz1cIi9ob3QuanNcIj48L3NjcmlwdD5cbiAgPHNjcmlwdCBzcmM9XCIke3VzZVJlZG9jUHJvXG4gICAgPyAnaHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L25wbS9AcmVkb2NseS9yZWZlcmVuY2UtZG9jc0BsYXRlc3QvZGlzdC9yZWRvY2x5LXJlZmVyZW5jZS1kb2NzLm1pbi5qcydcbiAgICA6ICdodHRwczovL2Nkbi5qc2RlbGl2ci5uZXQvbnBtL3JlZG9jQGxhdGVzdC9idW5kbGVzL3JlZG9jLnN0YW5kYWxvbmUuanMnfVwiPjwvc2NyaXB0PlxuYCxcbiAgICByZWRvY0hUTUw6IGBcbiAgPGRpdiBpZD1cInJlZG9jXCI+PC9kaXY+XG4gIDxzY3JpcHQ+XG4gICAgdmFyIGNvbnRhaW5lciA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdyZWRvYycpO1xuICAgICR7dXNlUmVkb2NQcm8gPyBcIndpbmRvd1t3aW5kb3cuX19SRURPQ19FWFBPUlRdLnNldFB1YmxpY1BhdGgoJ2h0dHBzOi8vY2RuLmpzZGVsaXZyLm5ldC9ucG0vQHJlZG9jbHkvcmVmZXJlbmNlLWRvY3NAbGF0ZXN0L2Rpc3QvJyk7XCIgOiAnJ31cbiAgICB3aW5kb3dbd2luZG93Ll9fUkVET0NfRVhQT1JUXS5pbml0KFwib3BlbmFwaS5qc29uXCIsICR7SlNPTi5zdHJpbmdpZnkocmVkb2NPcHRpb25zKX0sIGNvbnRhaW5lcilcbiAgPC9zY3JpcHQ+YCxcbiAgfSk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGFzeW5jIGZ1bmN0aW9uIHN0YXJ0UHJldmlld1NlcnZlcihwb3J0LCB7XG4gIGdldEJ1bmRsZSxcbiAgZ2V0T3B0aW9ucyxcbiAgdXNlUmVkb2NQcm8sXG59KSB7XG4gIGNvbnN0IGRlZmF1bHRUZW1wbGF0ZSA9IHBhdGguam9pbihfX2Rpcm5hbWUsICdkZWZhdWx0LmhicycpO1xuICBjb25zdCBoYW5kbGVyID0gYXN5bmMgKHJlcXVlc3QsIHJlc3BvbnNlKSA9PiB7XG4gICAgY29uc29sZS50aW1lKGNoYWxrLmRpbShgR0VUICR7cmVxdWVzdC51cmx9YCkpO1xuICAgIGNvbnN0IHsgaHRtbFRlbXBsYXRlIH0gPSBnZXRPcHRpb25zKCkgfHwge307XG5cbiAgICBpZiAocmVxdWVzdC51cmwgPT09ICcvJykge1xuICAgICAgcmVzcG9uZFdpdGhHemlwKGdldFBhZ2VIVE1MKGh0bWxUZW1wbGF0ZSB8fCBkZWZhdWx0VGVtcGxhdGUsIGdldE9wdGlvbnMoKSwgdXNlUmVkb2NQcm8sIHdzUG9ydCksIHJlcXVlc3QsIHJlc3BvbnNlLCB7XG4gICAgICAgICdDb250ZW50LVR5cGUnOiAndGV4dC9odG1sJyxcbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAocmVxdWVzdC51cmwgPT09ICcvb3BlbmFwaS5qc29uJykge1xuICAgICAgcmVzcG9uZFdpdGhHemlwKEpTT04uc3RyaW5naWZ5KGF3YWl0IGdldEJ1bmRsZSgpKSwgcmVxdWVzdCwgcmVzcG9uc2UsIHtcbiAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBmaWxlUGF0aCA9IHtcbiAgICAgICAgJy9ob3QuanMnOiBwYXRoLmpvaW4oX19kaXJuYW1lLCAnaG90LmpzJyksXG4gICAgICAgICcvc2ltcGxld2Vic29ja2V0Lm1pbi5qcyc6IHJlcXVpcmUucmVzb2x2ZSgnc2ltcGxlLXdlYnNvY2tldC9zaW1wbGV3ZWJzb2NrZXQubWluLmpzJyksXG4gICAgICB9W3JlcXVlc3QudXJsXSB8fCBwYXRoLnJlc29sdmUoaHRtbFRlbXBsYXRlID8gcGF0aC5kaXJuYW1lKGh0bWxUZW1wbGF0ZSkgOiBwcm9jZXNzLmN3ZCgpLCBgLiR7cmVxdWVzdC51cmx9YCk7XG5cbiAgICAgIGNvbnN0IGV4dG5hbWUgPSBTdHJpbmcocGF0aC5leHRuYW1lKGZpbGVQYXRoKSkudG9Mb3dlckNhc2UoKTtcblxuICAgICAgY29uc3QgY29udGVudFR5cGUgPSBtaW1lVHlwZXNbZXh0bmFtZV0gfHwgJ2FwcGxpY2F0aW9uL29jdGV0LXN0cmVhbSc7XG4gICAgICB0cnkge1xuICAgICAgICByZXNwb25kV2l0aEd6aXAoYXdhaXQgZnNQcm9taXNlcy5yZWFkRmlsZShmaWxlUGF0aCksIHJlcXVlc3QsIHJlc3BvbnNlLCB7XG4gICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6IGNvbnRlbnRUeXBlLFxuICAgICAgICB9KTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgaWYgKGUuY29kZSA9PT0gJ0VOT0VOVCcpIHtcbiAgICAgICAgICByZXNwb25kV2l0aEd6aXAoJzQwNCBOb3QgRm91bmQnLCByZXF1ZXN0LCByZXNwb25zZSwgeyAnQ29udGVudC1UeXBlJzogJ3RleHQvaHRtbCcgfSwgNDA0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXNwb25kV2l0aEd6aXAoYFNvbWV0aGluZyB3ZW50IHdyb25nOiAke2UuY29kZSB8fCBlLm1lc3NhZ2V9Li4uXFxuYCwgcmVxdWVzdCwgcmVzcG9uc2UsIHt9LCA1MDApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnNvbGUudGltZUVuZChjaGFsay5kaW0oYEdFVCAke3JlcXVlc3QudXJsfWApKTtcbiAgfTtcblxuICBsZXQgd3NQb3J0ID0gYXdhaXQgcG9ydGZpbmRlci5nZXRQb3J0UHJvbWlzZSh7IHBvcnQ6IDMyMjAxIH0pO1xuXG4gIGNvbnN0IHNlcnZlciA9IHN0YXJ0SHR0cFNlcnZlcihwb3J0LCBoYW5kbGVyKTtcbiAgc2VydmVyLm9uKCdsaXN0ZW5pbmcnLCAoKSA9PiB7XG4gICAgcHJvY2Vzcy5zdGRvdXQud3JpdGUoYFxcbiAg8J+UjiAgUHJldmlldyBzZXJ2ZXIgcnVubmluZyBhdCAke2NoYWxrLmJsdWUoYGh0dHA6Ly8xMjcuMC4wLjE6JHtwb3J0fVxcbmApfWApO1xuICB9KTtcblxuICByZXR1cm4gc3RhcnRXc1NlcnZlcih3c1BvcnQpO1xufVxuIl19