"use strict";

var _path = _interopRequireDefault(require("path"));

var _lodash = _interopRequireDefault(require("lodash.isequal"));

var _default = require("../error/default");

var _OpenAPISchema = _interopRequireDefault(require("../types/OAS3/OpenAPISchema"));

var _OpenAPIDiscriminator = require("../types/OAS3/OpenAPIDiscriminator");

var _utils = require("../utils");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/* eslint-disable no-case-declarations */

/* eslint-disable no-param-reassign */

/* eslint-disable class-methods-use-this */
const getComponentName = (refString, components, componentType, node, ctx) => {
  const errors = [];
  const [filePath, pointer] = refString.split('#/');
  const itemNameBase = pointer ? _path.default.basename(pointer) : _path.default.basename(filePath, _path.default.extname(filePath));

  const pathParts = _path.default.dirname(refString.replace('#/', '/')).split('/');

  const componentsGroup = components[componentType];
  if (!componentsGroup) return {
    name: itemNameBase,
    errors
  };
  let name = itemNameBase;
  let i = pathParts.length - 1;

  while (componentsGroup[name] && !(0, _lodash.default)(componentsGroup[name], node) && i >= 0) {
    const prevName = name;
    name = `${pathParts[i]}_${itemNameBase}`;
    errors.push(ctx.createError(`Two schemas are referenced with the same name but different content. Renamed ${prevName} to ${name}`, 'key'));
    i--;
  }

  if (i >= 0) return {
    name,
    errors
  };
  let serialId = 0;

  while (componentsGroup[name] && !(0, _lodash.default)(componentsGroup[name], node)) {
    serialId++;
    name = `${name}-${serialId}`;
  }

  return {
    name,
    errors
  };
};

class Bundler {
  constructor(config) {
    this.config = config;
    this.nameConflictsEnabled = this.config.nameConflicts !== 'off';

    if (this.nameConflictsEnabled) {
      this.nameConflictsSeverity = (0, _default.getMsgLevelFromString)(this.config.nameConflicts || '');
    }

    this.components = {};
    this.oas2components = {};
    this.newRefNodes = new Map();
  }

  static get rule() {
    return 'bundler';
  }

  defNameToType(definitionName) {
    switch (definitionName) {
      case 'OpenAPISchema':
        return 'schemas';

      case 'OpenAPIParameter':
        return 'parameters';

      case 'OpenAPIResponse':
        return 'responses';

      case 'OpenAPIExample':
        return 'examples';

      case 'OpenAPIRequestBody':
        return 'requestBodies';

      case 'OpenAPIHeader':
        return 'headers';

      case 'OpenAPISecuritySchema':
        return 'securitySchemes';

      case 'OpenAPILink':
        return 'links';

      case 'OpenAPICallback':
        return 'callbacks';

      case 'OAS2Schema':
        return 'definitions';

      case 'OAS2Response':
        return 'responses';

      case 'OAS2Parameter':
        return 'parameters';

      default:
        return null;
    }
  }

  includeImplicitDiscriminator(pointer, schemas, ctx, {
    traverseNode,
    visited
  }) {
    const $ref = `#/${pointer.join('/')}`;
    const errors = [];

    for (const [name, schema] of Object.entries(schemas || {})) {
      if (schema.allOf && schema.allOf.find(s => s.$ref === $ref)) {
        const existingSchema = this.components.schemas && this.components.schemas[name];

        if (existingSchema && !(0, _lodash.default)(existingSchema, schema)) {
          errors.push(ctx.createError(`Implicitly mapped discriminator schema "${name}" conflicts with existing schema. Skipping.`, 'key'));
        }

        this.components.schemas = this.components.schemas || {};
        this.components.schemas[name] = schema;
        ctx.pathStack.push({
          path: ctx.path,
          file: ctx.filePath,
          document: ctx.document,
          source: ctx.source
        });
        ctx.path = ['components', 'schemas', name];
        traverseNode(schema, _OpenAPISchema.default, ctx, visited);
        ctx.path = ctx.pathStack.pop().path;
      }
    }

    return errors;
  }

  saveComponent(ctx, node, name, componentType) {
    let ref;

    if (ctx.openapiVersion === 3) {
      ref = `#/components/${componentType}/${name}`;

      if (!this.components[componentType]) {
        this.components[componentType] = {};
      }

      this.components[componentType][name] = node;
    } else {
      switch (componentType) {
        case 'definitions':
          ref = `#/definitions/${name}`;
          break;

        case 'parameters':
          ref = `#/parameters/${name}`;
          break;

        case 'responses':
          ref = `#/responses/${name}`;
          break;

        default:
          return null;
      }

      if (!this.oas2components[componentType]) {
        this.oas2components[componentType] = {};
      }

      this.oas2components[componentType][name] = node;
    }

    return ref;
  }

  any() {
    return {
      onExit: (node, definition, ctx, unresolvedNode, {
        traverseNode,
        visited
      }) => {
        let errors = [];

        if (ctx.openapiVersion === 3 && node.discriminator && !node.oneOf && !node.anyOf && !node.mapping) {
          errors = this.includeImplicitDiscriminator(ctx.path, ctx.document.components && ctx.document.components.schemas, ctx, {
            traverseNode,
            visited
          });
        }

        if (unresolvedNode && node !== unresolvedNode && (0, _utils.isRef)(unresolvedNode)) {
          const componentType = this.defNameToType(definition.name);

          if (!componentType) {
            delete unresolvedNode.$ref;
            Object.assign(unresolvedNode, node);
          } else if (!this.newRefNodes.has(unresolvedNode)) {
            const {
              name,
              errors: nameErrors
            } = getComponentName(unresolvedNode.$ref, this.components, componentType, node, ctx);

            if (!name) {
              return errors;
            }

            errors.push(...nameErrors);
            const newRef = this.saveComponent(ctx, node, name, componentType);

            if (!newRef) {
              delete unresolvedNode.$ref;
              Object.assign(unresolvedNode, node);
              return errors;
            } // we can't replace nodes in-place as non-idempotent
            // nodes will be visited again and will fail bundling
            // so we save it and replace at the end


            this.newRefNodes.set(unresolvedNode, newRef);
          }
        }

        errors.forEach(e => {
          e.severity = this.nameConflictsSeverity;
        });

        if (!this.nameConflictsEnabled) {
          errors = [];
        }

        return errors;
      }
    };
  }

  OAS2Root() {
    return {
      onExit: (node, definition, ctx) => {
        if (!this.config.ignoreErrors && ctx.result.some(e => e.severity === _default.messageLevels.ERROR)) {
          ctx.bundlingResult = null;
          return null;
        }

        for (const [unresolvedNode, newRef] of this.newRefNodes.entries()) {
          unresolvedNode.$ref = newRef;
        }

        Object.keys(this.oas2components).forEach(component => {
          node[component] = node[component] ? node[component] : {};
          Object.assign(node[component], this.oas2components[component]);
        });
        ctx.bundlingResult = node;
        return null;
      }
    };
  }

  OpenAPIRoot() {
    return {
      onExit: (node, definition, ctx) => {
        if (!node.components) {
          node.components = {};
        }

        if (!this.config.ignoreErrors && ctx.result.some(e => e.severity === _default.messageLevels.ERROR)) {
          ctx.bundlingResult = null;
          return null;
        }

        for (const [unresolvedNode, newRef] of this.newRefNodes.entries()) {
          if (unresolvedNode[_OpenAPIDiscriminator.MAPPING_DATA_KEY]) {
            // FIXME: too hack
            const {
              mapping,
              key
            } = unresolvedNode[_OpenAPIDiscriminator.MAPPING_DATA_KEY];
            mapping[key] = newRef;
          } else {
            unresolvedNode.$ref = newRef;
          }
        }

        Object.keys(this.components).forEach(component => {
          node.components[component] = node.components[component] ? node.components[component] : {};
          Object.assign(node.components[component], this.components[component]);
        });
        ctx.bundlingResult = node;
        return null;
      }
    };
  }

}

module.exports = Bundler;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy92aXNpdG9ycy9idW5kbGVyLmpzIl0sIm5hbWVzIjpbImdldENvbXBvbmVudE5hbWUiLCJyZWZTdHJpbmciLCJjb21wb25lbnRzIiwiY29tcG9uZW50VHlwZSIsIm5vZGUiLCJjdHgiLCJlcnJvcnMiLCJmaWxlUGF0aCIsInBvaW50ZXIiLCJzcGxpdCIsIml0ZW1OYW1lQmFzZSIsInBhdGgiLCJiYXNlbmFtZSIsImV4dG5hbWUiLCJwYXRoUGFydHMiLCJkaXJuYW1lIiwicmVwbGFjZSIsImNvbXBvbmVudHNHcm91cCIsIm5hbWUiLCJpIiwibGVuZ3RoIiwicHJldk5hbWUiLCJwdXNoIiwiY3JlYXRlRXJyb3IiLCJzZXJpYWxJZCIsIkJ1bmRsZXIiLCJjb25zdHJ1Y3RvciIsImNvbmZpZyIsIm5hbWVDb25mbGljdHNFbmFibGVkIiwibmFtZUNvbmZsaWN0cyIsIm5hbWVDb25mbGljdHNTZXZlcml0eSIsIm9hczJjb21wb25lbnRzIiwibmV3UmVmTm9kZXMiLCJNYXAiLCJydWxlIiwiZGVmTmFtZVRvVHlwZSIsImRlZmluaXRpb25OYW1lIiwiaW5jbHVkZUltcGxpY2l0RGlzY3JpbWluYXRvciIsInNjaGVtYXMiLCJ0cmF2ZXJzZU5vZGUiLCJ2aXNpdGVkIiwiJHJlZiIsImpvaW4iLCJzY2hlbWEiLCJPYmplY3QiLCJlbnRyaWVzIiwiYWxsT2YiLCJmaW5kIiwicyIsImV4aXN0aW5nU2NoZW1hIiwicGF0aFN0YWNrIiwiZmlsZSIsImRvY3VtZW50Iiwic291cmNlIiwiT3BlbkFQSVNjaGVtYU9iamVjdCIsInBvcCIsInNhdmVDb21wb25lbnQiLCJyZWYiLCJvcGVuYXBpVmVyc2lvbiIsImFueSIsIm9uRXhpdCIsImRlZmluaXRpb24iLCJ1bnJlc29sdmVkTm9kZSIsImRpc2NyaW1pbmF0b3IiLCJvbmVPZiIsImFueU9mIiwibWFwcGluZyIsImFzc2lnbiIsImhhcyIsIm5hbWVFcnJvcnMiLCJuZXdSZWYiLCJzZXQiLCJmb3JFYWNoIiwiZSIsInNldmVyaXR5IiwiT0FTMlJvb3QiLCJpZ25vcmVFcnJvcnMiLCJyZXN1bHQiLCJzb21lIiwibWVzc2FnZUxldmVscyIsIkVSUk9SIiwiYnVuZGxpbmdSZXN1bHQiLCJrZXlzIiwiY29tcG9uZW50IiwiT3BlbkFQSVJvb3QiLCJNQVBQSU5HX0RBVEFfS0VZIiwia2V5IiwibW9kdWxlIiwiZXhwb3J0cyJdLCJtYXBwaW5ncyI6Ijs7QUFHQTs7QUFDQTs7QUFFQTs7QUFDQTs7QUFDQTs7QUFDQTs7OztBQVRBOztBQUNBOztBQUNBO0FBU0EsTUFBTUEsZ0JBQWdCLEdBQUcsQ0FBQ0MsU0FBRCxFQUFZQyxVQUFaLEVBQXdCQyxhQUF4QixFQUF1Q0MsSUFBdkMsRUFBNkNDLEdBQTdDLEtBQXFEO0FBQzVFLFFBQU1DLE1BQU0sR0FBRyxFQUFmO0FBRUEsUUFBTSxDQUFDQyxRQUFELEVBQVdDLE9BQVgsSUFBc0JQLFNBQVMsQ0FBQ1EsS0FBVixDQUFnQixJQUFoQixDQUE1QjtBQUVBLFFBQU1DLFlBQVksR0FBR0YsT0FBTyxHQUFHRyxjQUFLQyxRQUFMLENBQWNKLE9BQWQsQ0FBSCxHQUE0QkcsY0FBS0MsUUFBTCxDQUFjTCxRQUFkLEVBQXdCSSxjQUFLRSxPQUFMLENBQWFOLFFBQWIsQ0FBeEIsQ0FBeEQ7O0FBQ0EsUUFBTU8sU0FBUyxHQUFHSCxjQUFLSSxPQUFMLENBQWFkLFNBQVMsQ0FBQ2UsT0FBVixDQUFrQixJQUFsQixFQUF3QixHQUF4QixDQUFiLEVBQTJDUCxLQUEzQyxDQUFpRCxHQUFqRCxDQUFsQjs7QUFFQSxRQUFNUSxlQUFlLEdBQUdmLFVBQVUsQ0FBQ0MsYUFBRCxDQUFsQztBQUNBLE1BQUksQ0FBQ2MsZUFBTCxFQUFzQixPQUFPO0FBQUVDLElBQUFBLElBQUksRUFBRVIsWUFBUjtBQUFzQkosSUFBQUE7QUFBdEIsR0FBUDtBQUV0QixNQUFJWSxJQUFJLEdBQUdSLFlBQVg7QUFDQSxNQUFJUyxDQUFDLEdBQUdMLFNBQVMsQ0FBQ00sTUFBVixHQUFtQixDQUEzQjs7QUFFQSxTQUFPSCxlQUFl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R0FBcUI3RSxJQUFyQjtBQUNBLGVBQU8sSUFBUDtBQUNEO0FBM0JJLEtBQVA7QUE2QkQ7O0FBcE9XOztBQXVPZG1GLE1BQU0sQ0FBQ0MsT0FBUCxHQUFpQi9ELE9BQWpCIiwic291cmNlc0NvbnRlbnQiOlsiLyogZXNsaW50LWRpc2FibGUgbm8tY2FzZS1kZWNsYXJhdGlvbnMgKi9cbi8qIGVzbGludC1kaXNhYmxlIG5vLXBhcmFtLXJlYXNzaWduICovXG4vKiBlc2xpbnQtZGlzYWJsZSBjbGFzcy1tZXRob2RzLXVzZS10aGlzICovXG5pbXBvcnQgcGF0aCBmcm9tICdwYXRoJztcbmltcG9ydCBpc0VxdWFsIGZyb20gJ2xvZGFzaC5pc2VxdWFsJztcblxuaW1wb3J0IHsgZ2V0TXNnTGV2ZWxGcm9tU3RyaW5nLCBtZXNzYWdlTGV2ZWxzIH0gZnJvbSAnLi4vZXJyb3IvZGVmYXVsdCc7XG5pbXBvcnQgT3BlbkFQSVNjaGVtYU9iamVjdCBmcm9tICcuLi90eXBlcy9PQVMzL09wZW5BUElTY2hlbWEnO1xuaW1wb3J0IHsgTUFQUElOR19EQVRBX0tFWSB9IGZyb20gJy4uL3R5cGVzL09BUzMvT3BlbkFQSURpc2NyaW1pbmF0b3InO1xuaW1wb3J0IHsgaXNSZWYgfSBmcm9tICcuLi91dGlscyc7XG5cbmNvbnN0IGdldENvbXBvbmVudE5hbWUgPSAocmVmU3RyaW5nLCBjb21wb25lbnRzLCBjb21wb25lbnRUeXBlLCBub2RlLCBjdHgpID0+IHtcbiAgY29uc3QgZXJyb3JzID0gW107XG5cbiAgY29uc3QgW2ZpbGVQYXRoLCBwb2ludGVyXSA9IHJlZlN0cmluZy5zcGxpdCgnIy8nKTtcblxuICBjb25zdCBpdGVtTmFtZUJhc2UgPSBwb2ludGVyID8gcGF0aC5iYXNlbmFtZShwb2ludGVyKSA6IHBhdGguYmFzZW5hbWUoZmlsZVBhdGgsIHBhdGguZXh0bmFtZShmaWxlUGF0aCkpO1xuICBjb25zdCBwYXRoUGFydHMgPSBwYXRoLmRpcm5hbWUocmVmU3RyaW5nLnJlcGxhY2UoJyMvJywgJy8nKSkuc3BsaXQoJy8nKTtcblxuICBjb25zdCBjb21wb25lbnRzR3JvdXAgPSBjb21wb25lbnRzW2NvbXBvbmVudFR5cGVdO1xuICBpZiAoIWNvbXBvbmVudHNHcm91cCkgcmV0dXJuIHsgbmFtZTogaXRlbU5hbWVCYXNlLCBlcnJvcnMgfTtcblxuICBsZXQgbmFtZSA9IGl0ZW1OYW1lQmFzZTtcbiAgbGV0IGkgPSBwYXRoUGFydHMubGVuZ3RoIC0gMTtcblxuICB3aGlsZSAoY29tcG9uZW50c0dyb3VwW25hbWVdICYmICFpc0VxdWFsKGNvbXBvbmVudHNHcm91cFtuYW1lXSwgbm9kZSkgJiYgaSA+PSAwKSB7XG4gICAgY29uc3QgcHJldk5hbWUgPSBuYW1lO1xuICAgIG5hbWUgPSBgJHtwYXRoUGFydHNbaV19XyR7aXRlbU5hbWVCYXNlfWA7XG5cbiAgICBlcnJvcnMucHVzaChcbiAgICAgIGN0eC5jcmVhdGVFcnJvcihcbiAgICAgICAgYFR3byBzY2hlbWFzIGFyZSByZWZlcmVuY2VkIHdpdGggdGhlIHNhbWUgbmFtZSBidXQgZGlmZmVyZW50IGNvbnRlbnQuIFJlbmFtZWQgJHtwcmV2TmFtZX0gdG8gJHtuYW1lfWAsXG4gICAgICAgICdrZXknLFxuICAgICAgKSxcbiAgICApO1xuICAgIGktLTtcbiAgfVxuXG4gIGlmIChpID49IDApIHJldHVybiB7IG5hbWUsIGVycm9ycyB9O1xuXG4gIGxldCBzZXJpYWxJZCA9IDA7XG4gIHdoaWxlIChjb21wb25lbnRzR3JvdXBbbmFtZV0gJiYgIWlzRXF1YWwoY29tcG9uZW50c0dyb3VwW25hbWVdLCBub2RlKSkge1xuICAgIHNlcmlhbElkKys7XG4gICAgbmFtZSA9IGAke25hbWV9LSR7c2VyaWFsSWR9YDtcbiAgfVxuXG4gIHJldHVybiB7IG5hbWUsIGVycm9ycyB9O1xufTtcblxuY2xhc3MgQnVuZGxlciB7XG4gIGNvbnN0cnVjdG9yKGNvbmZpZykge1xuICAgIHRoaXMuY29uZmlnID0gY29uZmlnO1xuICAgIHRoaXMubmFtZUNvbmZsaWN0c0VuYWJsZWQgPSB0aGlzLmNvbmZpZy5uYW1lQ29uZmxpY3RzICE9PSAnb2ZmJztcbiAgICBpZiAodGhpcy5uYW1lQ29uZmxpY3RzRW5hYmxlZCkge1xuICAgICAgdGhpcy5uYW1lQ29uZmxpY3RzU2V2ZXJpdHkgPSBnZXRNc2dMZXZlbEZyb21TdHJpbmcodGhpcy5jb25maWcubmFtZUNvbmZsaWN0cyB8fCAnJyk7XG4gICAgfVxuICAgIHRoaXMuY29tcG9uZW50cyA9IHt9O1xuICAgIHRoaXMub2FzMmNvbXBvbmVudHMgPSB7fTtcblxuICAgIHRoaXMubmV3UmVmTm9kZXMgPSBuZXcgTWFwKCk7XG4gIH1cblxuICBzdGF0aWMgZ2V0IHJ1bGUoKSB7XG4gICAgcmV0dXJuICdidW5kbGVyJztcbiAgfVxuXG4gIGRlZk5hbWVUb1R5cGUoZGVmaW5pdGlvbk5hbWUpIHtcbiAgICBzd2l0Y2ggKGRlZmluaXRpb25OYW1lKSB7XG4gICAgICBjYXNlICdPcGVuQVBJU2NoZW1hJzpcbiAgICAgICAgcmV0dXJuICdzY2hlbWFzJztcbiAgICAgIGNhc2UgJ09wZW5BUElQYXJhbWV0ZXInOlxuICAgICAgICByZXR1cm4gJ3BhcmFtZXRlcnMnO1xuICAgICAgY2FzZSAnT3BlbkFQSVJlc3BvbnNlJzpcbiAgICAgICAgcmV0dXJuICdyZXNwb25zZXMnO1xuICAgICAgY2FzZSAnT3BlbkFQSUV4YW1wbGUnOlxuICAgICAgICByZXR1cm4gJ2V4YW1wbGVzJztcbiAgICAgIGNhc2UgJ09wZW5BUElSZXF1ZXN0Qm9keSc6XG4gICAgICAgIHJldHVybiAncmVxdWVzdEJvZGllcyc7XG4gICAgICBjYXNlICdPcGVuQVBJSGVhZGVyJzpcbiAgICAgICAgcmV0dXJuICdoZWFkZXJzJztcbiAgICAgIGNhc2UgJ09wZW5BUElTZWN1cml0eVNjaGVtYSc6XG4gICAgICAgIHJldHVybiAnc2VjdXJpdHlTY2hlbWVzJztcbiAgICAgIGNhc2UgJ09wZW5BUElMaW5rJzpcbiAgICAgICAgcmV0dXJuICdsaW5rcyc7XG4gICAgICBjYXNlICdPcGVuQVBJQ2FsbGJhY2snOlxuICAgICAgICByZXR1cm4gJ2NhbGxiYWNrcyc7XG4gICAgICBjYXNlICdPQVMyU2NoZW1hJzpcbiAgICAgICAgcmV0dXJuICdkZWZpbml0aW9ucyc7XG4gICAgICBjYXNlICdPQVMyUmVzcG9uc2UnOlxuICAgICAgICByZXR1cm4gJ3Jlc3BvbnNlcyc7XG4gICAgICBjYXNlICdPQVMyUGFyYW1ldGVyJzpcbiAgICAgICAgcmV0dXJuICdwYXJhbWV0ZXJzJztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfVxuXG4gIGluY2x1ZGVJbXBsaWNpdERpc2NyaW1pbmF0b3IocG9pbnRlciwgc2NoZW1hcywgY3R4LCB7IHRyYXZlcnNlTm9kZSwgdmlzaXRlZCB9KSB7XG4gICAgY29uc3QgJHJlZiA9IGAjLyR7cG9pbnRlci5qb2luKCcvJyl9YDtcbiAgICBjb25zdCBlcnJvcnMgPSBbXTtcblxuICAgIGZvciAoY29uc3QgW25hbWUsIHNjaGVtYV0gb2YgT2JqZWN0LmVudHJpZXMoc2NoZW1hcyB8fCB7fSkpIHtcbiAgICAgIGlmIChzY2hlbWEuYWxsT2YgJiYgc2NoZW1hLmFsbE9mLmZpbmQoKHMpID0+IHMuJHJlZiA9PT0gJHJlZikpIHtcbiAgICAgICAgY29uc3QgZXhpc3RpbmdTY2hlbWEgPSB0aGlzLmNvbXBvbmVudHMuc2NoZW1hcyAmJiB0aGlzLmNvbXBvbmVudHMuc2NoZW1hc1tuYW1lXTtcbiAgICAgICAgaWYgKGV4aXN0aW5nU2NoZW1hICYmICFpc0VxdWFsKGV4aXN0aW5nU2NoZW1hLCBzY2hlbWEpKSB7XG4gICAgICAgICAgZXJyb3JzLnB1c2goY3R4LmNyZWF0ZUVycm9yKFxuICAgICAgICAgICAgYEltcGxpY2l0bHkgbWFwcGVkIGRpc2NyaW1pbmF0b3Igc2NoZW1hIFwiJHtuYW1lfVwiIGNvbmZsaWN0cyB3aXRoIGV4aXN0aW5nIHNjaGVtYS4gU2tpcHBpbmcuYCwgJ2tleScsXG4gICAgICAgICAgKSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmNvbXBvbmVudHMuc2NoZW1hcyA9IHRoaXMuY29tcG9uZW50cy5zY2hlbWFzIHx8IHt9O1xuICAgICAgICB0aGlzLmNvbXBvbmVudHMuc2NoZW1hc1tuYW1lXSA9IHNjaGVtYTtcblxuICAgICAgICBjdHgucGF0aFN0YWNrLnB1c2goe1xuICAgICAgICAgIHBhdGg6IGN0eC5wYXRoLFxuICAgICAgICAgIGZpbGU6IGN0eC5maWxlUGF0aCxcbiAgICAgICAgICBkb2N1bWVudDogY3R4LmRvY3VtZW50LFxuICAgICAgICAgIHNvdXJjZTogY3R4LnNvdXJjZSxcbiAgICAgICAgfSk7XG5cbiAgICAgICAgY3R4LnBhdGggPSBbJ2NvbXBvbmVudHMnLCAnc2NoZW1hcycsIG5hbWVdO1xuICAgICAgICB0cmF2ZXJzZU5vZGUoc2NoZW1hLCBPcGVuQVBJU2NoZW1hT2JqZWN0LCBjdHgsIHZpc2l0ZWQpO1xuICAgICAgICBjdHgucGF0aCA9IGN0eC5wYXRoU3RhY2sucG9wKCkucGF0aDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZXJyb3JzO1xuICB9XG5cbiAgc2F2ZUNvbXBvbmVudChjdHgsIG5vZGUsIG5hbWUsIGNvbXBvbmVudFR5cGUpIHtcbiAgICBsZXQgcmVmO1xuICAgIGlmIChjdHgub3BlbmFwaVZlcnNpb24gPT09IDMpIHtcbiAgICAgIHJlZiA9IGAjL2NvbXBvbmVudHMvJHtjb21wb25lbnRUeXBlfS8ke25hbWV9YDtcblxuICAgICAgaWYgKCF0aGlzLmNvbXBvbmVudHNbY29tcG9uZW50VHlwZV0pIHtcbiAgICAgICAgdGhpcy5jb21wb25lbnRzW2NvbXBvbmVudFR5cGVdID0ge307XG4gICAgICB9XG5cbiAgICAgIHRoaXMuY29tcG9uZW50c1tjb21wb25lbnRUeXBlXVtuYW1lXSA9IG5vZGU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN3aXRjaCAoY29tcG9uZW50VHlwZSkge1xuICAgICAgICBjYXNlICdkZWZpbml0aW9ucyc6XG4gICAgICAgICAgcmVmID0gYCMvZGVmaW5pdGlvbnMvJHtuYW1lfWA7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ3BhcmFtZXRlcnMnOlxuICAgICAgICAgIHJlZiA9IGAjL3BhcmFtZXRlcnMvJHtuYW1lfWA7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ3Jlc3BvbnNlcyc6XG4gICAgICAgICAgcmVmID0gYCMvcmVzcG9uc2VzLyR7bmFtZX1gO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgICBpZiAoIXRoaXMub2FzMmNvbXBvbmVudHNbY29tcG9uZW50VHlwZV0pIHtcbiAgICAgICAgdGhpcy5vYXMyY29tcG9uZW50c1tjb21wb25lbnRUeXBlXSA9IHt9O1xuICAgICAgfVxuICAgICAgdGhpcy5vYXMyY29tcG9uZW50c1tjb21wb25lbnRUeXBlXVtuYW1lXSA9IG5vZGU7XG4gICAgfVxuICAgIHJldHVybiByZWY7XG4gIH1cblxuICBhbnkoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIG9uRXhpdDogKG5vZGUsIGRlZmluaXRpb24sIGN0eCwgdW5yZXNvbHZlZE5vZGUsIHsgdHJhdmVyc2VOb2RlLCB2aXNpdGVkIH0pID0+IHtcbiAgICAgICAgbGV0IGVycm9ycyA9IFtdO1xuXG4gICAgICAgIGlmIChjdHgub3BlbmFwaVZlcnNpb24gPT09IDNcbiAgICAgICAgICAmJiBub2RlLmRpc2NyaW1pbmF0b3JcbiAgICAgICAgICAmJiAhbm9kZS5vbmVPZlxuICAgICAgICAgICYmICFub2RlLmFueU9mXG4gICAgICAgICAgJiYgIW5vZGUubWFwcGluZykge1xuICAgICAgICAgIGVycm9ycyA9IHRoaXMuaW5jbHVkZUltcGxpY2l0RGlzY3JpbWluYXRvcihcbiAgICAgICAgICAgIGN0eC5wYXRoLFxuICAgICAgICAgICAgY3R4LmRvY3VtZW50LmNvbXBvbmVudHMgJiYgY3R4LmRvY3VtZW50LmNvbXBvbmVudHMuc2NoZW1hcyxcbiAgICAgICAgICAgIGN0eCxcbiAgICAgICAgICAgIHsgdHJhdmVyc2VOb2RlLCB2aXNpdGVkIH0sXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh1bnJlc29sdmVkTm9kZSAmJiBub2RlICE9PSB1bnJlc29sdmVkTm9kZSAmJiBpc1JlZih1bnJlc29sdmVkTm9kZSkpIHtcbiAgICAgICAgICBjb25zdCBjb21wb25lbnRUeXBlID0gdGhpcy5kZWZOYW1lVG9UeXBlKGRlZmluaXRpb24ubmFtZSk7XG5cbiAgICAgICAgICBpZiAoIWNvbXBvbmVudFR5cGUpIHtcbiAgICAgICAgICAgIGRlbGV0ZSB1bnJlc29sdmVkTm9kZS4kcmVmO1xuICAgICAgICAgICAgT2JqZWN0LmFzc2lnbih1bnJlc29sdmVkTm9kZSwgbm9kZSk7XG4gICAgICAgICAgfSBlbHNlIGlmICghdGhpcy5uZXdSZWZOb2Rlcy5oYXModW5yZXNvbHZlZE5vZGUpKSB7XG4gICAgICAgICAgICBjb25zdCB7IG5hbWUsIGVycm9yczogbmFtZUVycm9ycyB9ID0gZ2V0Q29tcG9uZW50TmFtZShcbiAgICAgICAgICAgICAgdW5yZXNvbHZlZE5vZGUuJHJlZiwgdGhpcy5jb21wb25lbnRzLCBjb21wb25lbnRUeXBlLCBub2RlLCBjdHgsXG4gICAgICAgICAgICApO1xuXG4gICAgICAgICAgICBpZiAoIW5hbWUpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGVycm9ycztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZXJyb3JzLnB1c2goLi4ubmFtZUVycm9ycyk7XG5cbiAgICAgICAgICAgIGNvbnN0IG5ld1JlZiA9IHRoaXMuc2F2ZUNvbXBvbmVudChjdHgsIG5vZGUsIG5hbWUsIGNvbXBvbmVudFR5cGUpO1xuICAgICAgICAgICAgaWYgKCFuZXdSZWYpIHtcbiAgICAgICAgICAgICAgZGVsZXRlIHVucmVzb2x2ZWROb2RlLiRyZWY7XG4gICAgICAgICAgICAgIE9iamVjdC5hc3NpZ24odW5yZXNvbHZlZE5vZGUsIG5vZGUpO1xuICAgICAgICAgICAgICByZXR1cm4gZXJyb3JzO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyB3ZSBjYW4ndCByZXBsYWNlIG5vZGVzIGluLXBsYWNlIGFzIG5vbi1pZGVtcG90ZW50XG4gICAgICAgICAgICAvLyBub2RlcyB3aWxsIGJlIHZpc2l0ZWQgYWdhaW4gYW5kIHdpbGwgZmFpbCBidW5kbGluZ1xuICAgICAgICAgICAgLy8gc28gd2Ugc2F2ZSBpdCBhbmQgcmVwbGFjZSBhdCB0aGUgZW5kXG4gICAgICAgICAgICB0aGlzLm5ld1JlZk5vZGVzLnNldCh1bnJlc29sdmVkTm9kZSwgbmV3UmVmKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBlcnJvcnMuZm9yRWFjaCgoZSkgPT4ge1xuICAgICAgICAgIGUuc2V2ZXJpdHkgPSB0aGlzLm5hbWVDb25mbGljdHNTZXZlcml0eTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKCF0aGlzLm5hbWVDb25mbGljdHNFbmFibGVkKSB7XG4gICAgICAgICAgZXJyb3JzID0gW107XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZXJyb3JzO1xuICAgICAgfSxcbiAgICB9O1xuICB9XG5cbiAgT0FTMlJvb3QoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIG9uRXhpdDogKG5vZGUsIGRlZmluaXRpb24sIGN0eCkgPT4ge1xuICAgICAgICBpZiAoIXRoaXMuY29uZmlnLmlnbm9yZUVycm9ycyAmJiBjdHgucmVzdWx0LnNvbWUoKGUpID0+IGUuc2V2ZXJpdHkgPT09IG1lc3NhZ2VMZXZlbHMuRVJST1IpKSB7XG4gICAgICAgICAgY3R4LmJ1bmRsaW5nUmVzdWx0ID0gbnVsbDtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAoY29uc3QgW3VucmVzb2x2ZWROb2RlLCBuZXdSZWZdIG9mIHRoaXMubmV3UmVmTm9kZXMuZW50cmllcygpKSB7XG4gICAgICAgICAgdW5yZXNvbHZlZE5vZGUuJHJlZiA9IG5ld1JlZjtcbiAgICAgICAgfVxuXG4gICAgICAgIE9iamVjdC5rZXlzKHRoaXMub2FzMmNvbXBvbmVudHMpLmZvckVhY2goKGNvbXBvbmVudCkgPT4ge1xuICAgICAgICAgIG5vZGVbY29tcG9uZW50XSA9IG5vZGVbY29tcG9uZW50XSA/IG5vZGVbY29tcG9uZW50XSA6IHt9O1xuICAgICAgICAgIE9iamVjdC5hc3NpZ24obm9kZVtjb21wb25lbnRdLCB0aGlzLm9hczJjb21wb25lbnRzW2NvbXBvbmVudF0pO1xuICAgICAgICB9KTtcblxuICAgICAgICBjdHguYnVuZGxpbmdSZXN1bHQgPSBub2RlO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH0sXG4gICAgfTtcbiAgfVxuXG4gIE9wZW5BUElSb290KCkge1xuICAgIHJldHVybiB7XG4gICAgICBvbkV4aXQ6IChub2RlLCBkZWZpbml0aW9uLCBjdHgpID0+IHtcbiAgICAgICAgaWYgKCFub2RlLmNvbXBvbmVudHMpIHtcbiAgICAgICAgICBub2RlLmNvbXBvbmVudHMgPSB7fTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghdGhpcy5jb25maWcuaWdub3JlRXJyb3JzICYmIGN0eC5yZXN1bHQuc29tZSgoZSkgPT4gZS5zZXZlcml0eSA9PT0gbWVzc2FnZUxldmVscy5FUlJPUikpIHtcbiAgICAgICAgICBjdHguYnVuZGxpbmdSZXN1bHQgPSBudWxsO1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChjb25zdCBbdW5yZXNvbHZlZE5vZGUsIG5ld1JlZl0gb2YgdGhpcy5uZXdSZWZOb2Rlcy5lbnRyaWVzKCkpIHtcbiAgICAgICAgICBpZiAodW5yZXNvbHZlZE5vZGVbTUFQUElOR19EQVRBX0tFWV0pIHsgLy8gRklYTUU6IHRvbyBoYWNrXG4gICAgICAgICAgICBjb25zdCB7IG1hcHBpbmcsIGtleSB9ID0gdW5yZXNvbHZlZE5vZGVbTUFQUElOR19EQVRBX0tFWV07XG4gICAgICAgICAgICBtYXBwaW5nW2tleV0gPSBuZXdSZWY7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHVucmVzb2x2ZWROb2RlLiRyZWYgPSBuZXdSZWY7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgT2JqZWN0LmtleXModGhpcy5jb21wb25lbnRzKS5mb3JFYWNoKChjb21wb25lbnQpID0+IHtcbiAgICAgICAgICBub2RlLmNvbXBvbmVudHNbY29tcG9uZW50XSA9IG5vZGUuY29tcG9uZW50c1tjb21wb25lbnRdID8gbm9kZS5jb21wb25lbnRzW2NvbXBvbmVudF0gOiB7fTtcbiAgICAgICAgICBPYmplY3QuYXNzaWduKG5vZGUuY29tcG9uZW50c1tjb21wb25lbnRdLCB0aGlzLmNvbXBvbmVudHNbY29tcG9uZW50XSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGN0eC5idW5kbGluZ1Jlc3VsdCA9IG5vZGU7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfSxcbiAgICB9O1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gQnVuZGxlcjtcbiJdfQ==