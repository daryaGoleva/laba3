"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.matchesJsonSchemaType = matchesJsonSchemaType;
exports.lexicalDistance = lexicalDistance;
exports.getClosestString = getClosestString;
exports.isRef = isRef;
exports.debounce = debounce;
exports.match = match;
exports.readYaml = readYaml;
exports.fileNotFoundError = fileNotFoundError;
exports.getFile = exports.getLineNumberFromId = exports.outputYellow = exports.outputBgYellow = exports.outputBgRed = exports.outputGrey = exports.outputLightBlue = exports.outputBgLightBlue = exports.outputUnderline = exports.outputRed = exports.isFullyQualifiedUrl = exports.isUrl = void 0;

var _chalk = _interopRequireDefault(require("chalk"));

var _nodeFetch = _interopRequireDefault(require("node-fetch"));

var _minimatch = _interopRequireDefault(require("minimatch"));

var _fs = _interopRequireDefault(require("fs"));

var _jsYaml = _interopRequireDefault(require("js-yaml"));

var _config = require("../config");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// @ts-check

/** @typedef {'string'|'number'|'integer'|'boolean'|'null'|'object'|'array'} JSONSchemaType */

/* eslint-disable import/prefer-default-export */
const urlPattern = new RegExp('^(https?:\\/\\/)?' // protocol
+ '((([a-z\\d]([a-z\\d-]*[a-z\\d])*)\\.)+[a-z]{2,}|' // domain name
+ '((\\d{1,3}\\.){3}\\d{1,3}))' // OR ip (v4) address
+ '(\\:\\d+)?(\\/[-a-z\\d%_.~+]*)*' // port and path
+ '(\\?[;&a-z\\d%_.~+=-]*)?' // query string
+ '(\\#[-a-z\\d_]*)?$', 'i'); // fragment locator

/* eslint-disable import/prefer-default-export */

const fullyQualifiedUrlPattern = new RegExp('^(https?:\\/\\/)' // protocol
+ '((([a-z\\d]([a-z\\d-]*[a-z\\d])*)\\.)+[a-z]{2,}|' // domain name
+ '((\\d{1,3}\\.){3}\\d{1,3}))' // OR ip (v4) address
+ '(\\:\\d+)?(\\/[-a-z\\d%_.~+]*)*' // port and path
+ '(\\?[;&a-z\\d%_.~+=-]*)?' // query string
+ '(\\#[-a-z\\d_]*)?$', 'i'); // fragment locator

const isUrl = string => urlPattern.test(string);

exports.isUrl = isUrl;

const isFullyQualifiedUrl = string => fullyQualifiedUrlPattern.test(string);

exports.isFullyQualifiedUrl = isFullyQualifiedUrl;

const outputRed = str => _chalk.default.red(str);

exports.outputRed = outputRed;

const outputUnderline = str => _chalk.default.underline(str);

exports.outputUnderline = outputUnderline;

const outputBgLightBlue = str => _chalk.default.bgBlueBright(str);

exports.outputBgLightBlue = outputBgLightBlue;

const outputLightBlue = str => _chalk.default.blueBright(str);

exports.outputLightBlue = outputLightBlue;

const outputGrey = str => _chalk.default.grey(str);

exports.outputGrey = outputGrey;

const outputBgRed = str => _chalk.default.bgRed(str);

exports.outputBgRed = outputBgRed;

const outputBgYellow = str => _chalk.default.bgYellow(str);

exports.outputBgYellow = outputBgYellow;

const outputYellow = str => _chalk.default.yellow(str);

exports.outputYellow = outputYellow;

const getLineNumberFromId = (source, charId) => {
  let lineNum = 1;
  let posNum = 0;

  for (let i = 0; i < charId; i += 1) {
    if (source[i] === '\n') {
      lineNum += 1;
      posNum = charId - i;
    }
  }

  return {
    lineNum,
    posNum
  };
};
/**
 * Checks if value matches specified JSON schema type
 *
 * @param {*} value - value to check
 * @param {JSONSchemaType} type - JSON Schema type
 * @returns string
 */


exports.getLineNumberFromId = getLineNumberFromId;

function matchesJsonSchemaType(value, type) {
  switch (type) {
    case 'array':
      return Array.isArray(value);

    case 'object':
      return typeof value === 'object' && value !== null && !Array.isArray(value);

    case 'null':
      return value === null;

    case 'integer':
      return Number.isInteger(value);

    default:
      // eslint-disable-next-line valid-typeof
      return typeof value === type;
  }
}
/**
  *
  * MIT License
  *
  * Copyright (c) 2019 GraphQL Contributors
  *
  * Permission is hereby granted, free of charge, to any person obtaining a copy
  * of this software and associated documentation files (the "Software"), to deal
  * in the Software without restriction, including without limitation the rights
  * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
  * copies of the Software, and to permit persons to whom the Software is
  * furnished to do so, subject to the following conditions:
  *
  * The above copyright notice and this permission notice shall be included in all
  * copies or substantial portions of the Software.
  *
  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
  * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
  * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
  * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
  * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
  * SOFTWARE.
  *
  * Computes the lexical distance between strings A and B.
  *
  * The "distance" between two strings is given by counting the minimum number
  * of edits needed to transform string A into string B. An edit can be an
  * insertion, deletion, or substitution of a single character, or a swap of two
  * adjacent characters.
  *
  * Includes a custom alteration from Damerau-Levenshtein to treat case changes
  * as a single edit which helps identify mis-cased values with an edit distance
  * of 1.
  *
  * This distance can be useful for detecting typos in input or sorting
  *
  * @param {string} aStr
  * @param {string} bStr
  * @return {number} distance in number of edits
  */


function lexicalDistance(aStr, bStr) {
  if (aStr === bStr) {
    return 0;
  }

  const d = [];
  const a = aStr.toLowerCase();
  const b = bStr.toLowerCase();
  const aLength = a.length;
  const bLength = b.length; // Any case change counts as a single edit

  if (a === b) {
    return 1;
  }

  for (let i = 0; i <= aLength; i++) {
    d[i] = [i];
  }

  for (let j = 1; j <= bLength; j++) {
    d[0][j] = j;
  }

  for (let i = 1; i <= aLength; i++) {
    for (let j = 1; j <= bLength; j++) {
      const cost = a[i - 1] === b[j - 1] ? 0 : 1;
      d[i][j] = Math.min(d[i - 1][j] + 1, d[i][j - 1] + 1, d[i - 1][j - 1] + cost);

      if (i > 1 && j > 1 && a[i - 1] === b[j - 2] && a[i - 2] === b[j - 1]) {
        d[i][j] = Math.min(d[i][j], d[i - 2][j - 2] + cost);
      }
    }
  }

  return d[aLength][bLength];
}

function getClosestString(given, others) {
  if (!others || others.length === 0) return null;
  let bestMatch = {
    string: others[0],
    distance: lexicalDistance(given, others[0])
  };

  for (let i = 0; i < others.length; i++) {
    const distance = lexicalDistance(given, others[i]);
    bestMatch = distance < bestMatch.distance ? {
      string: others[i],
      distance
    } : bestMatch;
  }

  if (bestMatch.distance <= 4) return bestMatch.string;
  return null;
}

const getFile = async link => {
  const resp = await (0, _nodeFetch.default)(link);
  return resp.text();
};

exports.getFile = getFile;

function isRef(node) {
  return node && Object.prototype.hasOwnProperty.call(node, '$ref');
}

function debounce(func, wait, immediate) {
  let timeout;
  return function executedFunction(...args) {
    const context = this;

    const later = () => {
      timeout = null;
      if (!immediate) func.apply(context, args);
    };

    const callNow = immediate && !timeout;
    clearTimeout(timeout);
    timeout = setTimeout(later, wait);
    if (callNow) func.apply(context, args);
  };
}

function match(url, pattern) {
  if (!pattern.match(/^https?:\/\//)) {
    // if pattern doesn't specify protocol directly, do not match against it
    url = url.replace(/^https?:\/\//, '');
  }

  return (0, _minimatch.default)(url, pattern);
} // we ignore this as in the bad-path we end up with terminating the process.
// eslint-disable-next-line consistent-return


function readYaml(filename) {
  let source;

  try {
    source = _fs.default.readFileSync(filename, 'utf-8');
  } catch (error) {
    const definitions = (0, _config.getDefinitionNames)();
    process.stderr.write(fileNotFoundError(filename, definitions));
    process.exit(1);
  }

  try {
    const document = _jsYaml.default.safeLoad(source, {
      filename
    });

    return {
      document,
      source
    };
  } catch (ex) {
    // console.log(ex);
    process.stderr.write(`Can't load yaml file. Error during parsing YAML source:\n${ex.message}\n`);
    process.exit(1);
  }
}

function fileNotFoundError(fName, definitions) {
  let errorMessage = `Can't find definition or file with name: ${_chalk.default.red(fName)}.\n`;

  if (definitions) {
    errorMessage = `${errorMessage}\nAvailable definitions:\n- ${definitions.join('\n- ')}\n`;
  }

  return errorMessage;
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy91dGlscy9pbmRleC5qcyJdLCJuYW1lcyI6WyJ1cmxQYXR0ZXJuIiwiUmVnRXhwIiwiZnVsbHlRdWFsaWZpZWRVcmxQYXR0ZXJuIiwiaXNVcmwiLCJzdHJpbmciLCJ0ZXN0IiwiaXNGdWxseVF1YWxpZmllZFVybCIsIm91dHB1dFJlZCIsInN0ciIsImNoYWxrIiwicmVkIiwib3V0cHV0VW5kZXJsaW5lIiwidW5kZXJsaW5lIiwib3V0cHV0QmdMaWdodEJsdWUiLCJiZ0JsdWVCcmlnaHQiLCJvdXRwdXRMaWdodEJsdWUiLCJibHVlQnJpZ2h0Iiwib3V0cHV0R3JleSIsImdyZXkiLCJvdXRwdXRCZ1JlZCIsImJnUmVkIiwib3V0cHV0QmdZZWxsb3ciLCJiZ1llbGxvdyIsIm91dHB1dFllbGxvdyIsInllbGxvdyIsImdldExpbmVOdW1iZXJGcm9tSWQiLCJzb3VyY2UiLCJjaGFySWQiLCJsaW5lTnVtIiwicG9zTnVtIiwiaSIsIm1hdGNoZXNKc29uU2NoZW1hVHlwZSIsInZhbHVlIiwidHlwZSIsIkFycmF5IiwiaXNBcnJheSIsIk51bWJlciIsImlzSW50ZWdlciIsImxleGljYWxEaXN0YW5jZSIsImFTdHIiLCJiU3RyIiwiZCIsImEiLCJ0b0xvd2VyQ2FzZSIsImIiLCJhTGVuZ3RoIiwibGVuZ3RoIiwiYkxlbmd0aCIsImoiLCJjb3N0IiwiTWF0aCIsIm1pbiIsImdldENsb3Nlc3RTdHJpbmciLCJnaXZlbiIsIm90aGVycyIsImJlc3RNYXRjaCIsImRpc3RhbmNlIiwiZ2V0RmlsZSIsImxpbmsiLCJyZXNwIiwidGV4dCIsImlzUmVmIiwibm9kZSIsIk9iamVjdCIsInByb3RvdHlwZSIsImhhc093blByb3BlcnR5IiwiY2FsbCIsImRlYm91bmNlIiwiZnVuYyIsIndhaXQiLCJpbW1lZGlhdGUiLCJ0aW1lb3V0IiwiZXhlY3V0ZWRGdW5jdGlvbiIsImFyZ3MiLCJjb250ZXh0IiwibGF0ZXIiLCJhcHBseSIsImNhbGxOb3ciLCJjbGVhclRpbWVvdXQiLCJzZXRUaW1lb3V0IiwibWF0Y2giLCJ1cmwiLCJwYXR0ZXJuIiwicmVwbGFjZSIsInJlYWRZYW1sIiwiZmlsZW5hbWUiLCJmcyIsInJlYWRGaWxlU3luYyIsImVycm9yIiwiZGVmaW5pdGlvbnMiLCJwcm9jZXNzIiwic3RkZXJyIiwid3JpdGUiLCJmaWxlTm90Rm91bmRFcnJvciIsImV4aXQiLCJkb2N1bWVudCIsInlhbWwiLCJzYWZlTG9hZCIsImV4IiwibWVzc2FnZSIsImZOYW1lIiwiZXJyb3JNZXNzYWdlIiwiam9pbiJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7O0FBR0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBRUE7Ozs7QUFUQTs7QUFDQTs7QUFVQTtBQUNBLE1BQU1BLFVBQVUsR0FBRyxJQUFJQyxNQUFKLENBQVcsb0JBQW9CO0FBQXBCLEVBQzVCLGtEQUQ0QixDQUN1QjtBQUR2QixFQUU1Qiw2QkFGNEIsQ0FFRTtBQUZGLEVBRzVCLGlDQUg0QixDQUdNO0FBSE4sRUFJNUIsMEJBSjRCLENBSUQ7QUFKQyxFQUs1QixvQkFMaUIsRUFLSyxHQUxMLENBQW5CLEMsQ0FLOEI7O0FBQzlCOztBQUNBLE1BQU1DLHdCQUF3QixHQUFHLElBQUlELE1BQUosQ0FBVyxtQkFBbUI7QUFBbkIsRUFDMUMsa0RBRDBDLENBQ1M7QUFEVCxFQUUxQyw2QkFGMEMsQ0FFWjtBQUZZLEVBRzFDLGlDQUgwQyxDQUdSO0FBSFEsRUFJMUMsMEJBSjBDLENBSWY7QUFKZSxFQUsxQyxvQkFMK0IsRUFLVCxHQUxTLENBQWpDLEMsQ0FLOEI7O0FBRXZCLE1BQU1FLEtBQUssR0FBSUMsTUFBRCxJQUFZSixVQUFVLENBQUNLLElBQVgsQ0FBZ0JELE1BQWhCLENBQTFCOzs7O0FBQ0EsTUFBTUUsbUJBQW1CLEdBQUlGLE1BQUQsSUFBWUYsd0JBQXdCLENBQUNHLElBQXpCLENBQThCRCxNQUE5QixDQUF4Qzs7OztBQUVBLE1BQU1HLFNBQVMsR0FBSUMsR0FBRCxJQUFTQyxlQUFNQyxHQUFOLENBQVVGLEdBQVYs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SSxHQUFFQSxZQUFhLCtCQUE4QlosV0FBVyxDQUFDYSxJQUFaLENBQWlCLE1BQWpCLENBQXlCLElBQXRGO0FBQ0Q7O0FBQ0QsU0FBT0QsWUFBUDtBQUNEIiwic291cmNlc0NvbnRlbnQiOlsiLy8gQHRzLWNoZWNrXG4vKiogQHR5cGVkZWYgeydzdHJpbmcnfCdudW1iZXInfCdpbnRlZ2VyJ3wnYm9vbGVhbid8J251bGwnfCdvYmplY3QnfCdhcnJheSd9IEpTT05TY2hlbWFUeXBlICovXG5cbmltcG9ydCBjaGFsayBmcm9tICdjaGFsayc7XG5pbXBvcnQgZmV0Y2ggZnJvbSAnbm9kZS1mZXRjaCc7XG5pbXBvcnQgbWluaW1hdGNoIGZyb20gJ21pbmltYXRjaCc7XG5pbXBvcnQgZnMgZnJvbSAnZnMnO1xuaW1wb3J0IHlhbWwgZnJvbSAnanMteWFtbCc7XG5cbmltcG9ydCB7IGdldERlZmluaXRpb25OYW1lcyB9IGZyb20gJy4uL2NvbmZpZyc7XG5cbi8qIGVzbGludC1kaXNhYmxlIGltcG9ydC9wcmVmZXItZGVmYXVsdC1leHBvcnQgKi9cbmNvbnN0IHVybFBhdHRlcm4gPSBuZXcgUmVnRXhwKCdeKGh0dHBzPzpcXFxcL1xcXFwvKT8nIC8vIHByb3RvY29sXG4rICcoKChbYS16XFxcXGRdKFthLXpcXFxcZC1dKlthLXpcXFxcZF0pKilcXFxcLikrW2Etel17Mix9fCcgLy8gZG9tYWluIG5hbWVcbisgJygoXFxcXGR7MSwzfVxcXFwuKXszfVxcXFxkezEsM30pKScgLy8gT1IgaXAgKHY0KSBhZGRyZXNzXG4rICcoXFxcXDpcXFxcZCspPyhcXFxcL1stYS16XFxcXGQlXy5+K10qKSonIC8vIHBvcnQgYW5kIHBhdGhcbisgJyhcXFxcP1s7JmEtelxcXFxkJV8ufis9LV0qKT8nIC8vIHF1ZXJ5IHN0cmluZ1xuKyAnKFxcXFwjWy1hLXpcXFxcZF9dKik/JCcsICdpJyk7IC8vIGZyYWdtZW50IGxvY2F0b3Jcbi8qIGVzbGludC1kaXNhYmxlIGltcG9ydC9wcmVmZXItZGVmYXVsdC1leHBvcnQgKi9cbmNvbnN0IGZ1bGx5UXVhbGlmaWVkVXJsUGF0dGVybiA9IG5ldyBSZWdFeHAoJ14oaHR0cHM/OlxcXFwvXFxcXC8pJyAvLyBwcm90b2NvbFxuKyAnKCgoW2EtelxcXFxkXShbYS16XFxcXGQtXSpbYS16XFxcXGRdKSopXFxcXC4pK1thLXpdezIsfXwnIC8vIGRvbWFpbiBuYW1lXG4rICcoKFxcXFxkezEsM31cXFxcLil7M31cXFxcZHsxLDN9KSknIC8vIE9SIGlwICh2NCkgYWRkcmVzc1xuKyAnKFxcXFw6XFxcXGQrKT8oXFxcXC9bLWEtelxcXFxkJV8ufitdKikqJyAvLyBwb3J0IGFuZCBwYXRoXG4rICcoXFxcXD9bOyZhLXpcXFxcZCVfLn4rPS1dKik/JyAvLyBxdWVyeSBzdHJpbmdcbisgJyhcXFxcI1stYS16XFxcXGRfXSopPyQnLCAnaScpOyAvLyBmcmFnbWVudCBsb2NhdG9yXG5cbmV4cG9ydCBjb25zdCBpc1VybCA9IChzdHJpbmcpID0+IHVybFBhdHRlcm4udGVzdChzdHJpbmcpO1xuZXhwb3J0IGNvbnN0IGlzRnVsbHlRdWFsaWZpZWRVcmwgPSAoc3RyaW5nKSA9PiBmdWxseVF1YWxpZmllZFVybFBhdHRlcm4udGVzdChzdHJpbmcpO1xuXG5leHBvcnQgY29uc3Qgb3V0cHV0UmVkID0gKHN0cikgPT4gY2hhbGsucmVkKHN0cik7XG5leHBvcnQgY29uc3Qgb3V0cHV0VW5kZXJsaW5lID0gKHN0cikgPT4gY2hhbGsudW5kZXJsaW5lKHN0cik7XG5leHBvcnQgY29uc3Qgb3V0cHV0QmdMaWdodEJsdWUgPSAoc3RyKSA9PiBjaGFsay5iZ0JsdWVCcmlnaHQoc3RyKTtcblxuZXhwb3J0IGNvbnN0IG91dHB1dExpZ2h0Qmx1ZSA9IChzdHIpID0+IGNoYWxrLmJsdWVCcmlnaHQoc3RyKTtcbmV4cG9ydCBjb25zdCBvdXRwdXRHcmV5ID0gKHN0cikgPT4gY2hhbGsuZ3JleShzdHIpO1xuZXhwb3J0IGNvbnN0IG91dHB1dEJnUmVkID0gKHN0cikgPT4gY2hhbGsuYmdSZWQoc3RyKTtcbmV4cG9ydCBjb25zdCBvdXRwdXRCZ1llbGxvdyA9IChzdHIpID0+IGNoYWxrLmJnWWVsbG93KHN0cik7XG5leHBvcnQgY29uc3Qgb3V0cHV0WWVsbG93ID0gKHN0cikgPT4gY2hhbGsueWVsbG93KHN0cik7XG5leHBvcnQgY29uc3QgZ2V0TGluZU51bWJlckZyb21JZCA9IChzb3VyY2UsIGNoYXJJZCkgPT4ge1xuICBsZXQgbGluZU51bSA9IDE7XG4gIGxldCBwb3NOdW0gPSAwO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGNoYXJJZDsgaSArPSAxKSB7XG4gICAgaWYgKHNvdXJjZVtpXSA9PT0gJ1xcbicpIHtcbiAgICAgIGxpbmVOdW0gKz0gMTtcbiAgICAgIHBvc051bSA9IGNoYXJJZCAtIGk7XG4gICAgfVxuICB9XG4gIHJldHVybiB7XG4gICAgbGluZU51bSxcbiAgICBwb3NOdW0sXG4gIH07XG59O1xuXG4vKipcbiAqIENoZWNrcyBpZiB2YWx1ZSBtYXRjaGVzIHNwZWNpZmllZCBKU09OIHNjaGVtYSB0eXBlXG4gKlxuICogQHBhcmFtIHsqfSB2YWx1ZSAtIHZhbHVlIHRvIGNoZWNrXG4gKiBAcGFyYW0ge0pTT05TY2hlbWFUeXBlfSB0eXBlIC0gSlNPTiBTY2hlbWEgdHlwZVxuICogQHJldHVybnMgc3RyaW5nXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtYXRjaGVzSnNvblNjaGVtYVR5cGUodmFsdWUsIHR5cGUpIHtcbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSAnYXJyYXknOlxuICAgICAgcmV0dXJuIEFycmF5LmlzQXJyYXkodmFsdWUpO1xuICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiB2YWx1ZSAhPT0gbnVsbCAmJiAhQXJyYXkuaXNBcnJheSh2YWx1ZSk7XG4gICAgY2FzZSAnbnVsbCc6XG4gICAgICByZXR1cm4gdmFsdWUgPT09IG51bGw7XG4gICAgY2FzZSAnaW50ZWdlcic6XG4gICAgICByZXR1cm4gTnVtYmVyLmlzSW50ZWdlcih2YWx1ZSk7XG4gICAgZGVmYXVsdDpcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSB2YWxpZC10eXBlb2ZcbiAgICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09IHR5cGU7XG4gIH1cbn1cblxuLyoqXG4gICpcbiAgKiBNSVQgTGljZW5zZVxuICAqXG4gICogQ29weXJpZ2h0IChjKSAyMDE5IEdyYXBoUUwgQ29udHJpYnV0b3JzXG4gICpcbiAgKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4gICogb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuICAqIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbiAgKiB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4gICogY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4gICogZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAgKlxuICAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluIGFsbFxuICAqIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gICpcbiAgKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4gICogSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4gICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4gICogQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuICAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4gICogT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEVcbiAgKiBTT0ZUV0FSRS5cbiAgKlxuICAqIENvbXB1dGVzIHRoZSBsZXhpY2FsIGRpc3RhbmNlIGJldHdlZW4gc3RyaW5ncyBBIGFuZCBCLlxuICAqXG4gICogVGhlIFwiZGlzdGFuY2VcIiBiZXR3ZWVuIHR3byBzdHJpbmdzIGlzIGdpdmVuIGJ5IGNvdW50aW5nIHRoZSBtaW5pbXVtIG51bWJlclxuICAqIG9mIGVkaXRzIG5lZWRlZCB0byB0cmFuc2Zvcm0gc3RyaW5nIEEgaW50byBzdHJpbmcgQi4gQW4gZWRpdCBjYW4gYmUgYW5cbiAgKiBpbnNlcnRpb24sIGRlbGV0aW9uLCBvciBzdWJzdGl0dXRpb24gb2YgYSBzaW5nbGUgY2hhcmFjdGVyLCBvciBhIHN3YXAgb2YgdHdvXG4gICogYWRqYWNlbnQgY2hhcmFjdGVycy5cbiAgKlxuICAqIEluY2x1ZGVzIGEgY3VzdG9tIGFsdGVyYXRpb24gZnJvbSBEYW1lcmF1LUxldmVuc2h0ZWluIHRvIHRyZWF0IGNhc2UgY2hhbmdlc1xuICAqIGFzIGEgc2luZ2xlIGVkaXQgd2hpY2ggaGVscHMgaWRlbnRpZnkgbWlzLWNhc2VkIHZhbHVlcyB3aXRoIGFuIGVkaXQgZGlzdGFuY2VcbiAgKiBvZiAxLlxuICAqXG4gICogVGhpcyBkaXN0YW5jZSBjYW4gYmUgdXNlZnVsIGZvciBkZXRlY3RpbmcgdHlwb3MgaW4gaW5wdXQgb3Igc29ydGluZ1xuICAqXG4gICogQHBhcmFtIHtzdHJpbmd9IGFTdHJcbiAgKiBAcGFyYW0ge3N0cmluZ30gYlN0clxuICAqIEByZXR1cm4ge251bWJlcn0gZGlzdGFuY2UgaW4gbnVtYmVyIG9mIGVkaXRzXG4gICovXG5leHBvcnQgZnVuY3Rpb24gbGV4aWNhbERpc3RhbmNlKGFTdHIsIGJTdHIpIHtcbiAgaWYgKGFTdHIgPT09IGJTdHIpIHtcbiAgICByZXR1cm4gMDtcbiAgfVxuXG4gIGNvbnN0IGQgPSBbXTtcbiAgY29uc3QgYSA9IGFTdHIudG9Mb3dlckNhc2UoKTtcbiAgY29uc3QgYiA9IGJTdHIudG9Mb3dlckNhc2UoKTtcbiAgY29uc3QgYUxlbmd0aCA9IGEubGVuZ3RoO1xuICBjb25zdCBiTGVuZ3RoID0gYi5sZW5ndGg7XG5cbiAgLy8gQW55IGNhc2UgY2hhbmdlIGNvdW50cyBhcyBhIHNpbmdsZSBlZGl0XG4gIGlmIChhID09PSBiKSB7XG4gICAgcmV0dXJuIDE7XG4gIH1cblxuICBmb3IgKGxldCBpID0gMDsgaSA8PSBhTGVuZ3RoOyBpKyspIHtcbiAgICBkW2ldID0gW2ldO1xuICB9XG5cbiAgZm9yIChsZXQgaiA9IDE7IGogPD0gYkxlbmd0aDsgaisrKSB7XG4gICAgZFswXVtqXSA9IGo7XG4gIH1cblxuICBmb3IgKGxldCBpID0gMTsgaSA8PSBhTGVuZ3RoOyBpKyspIHtcbiAgICBmb3IgKGxldCBqID0gMTsgaiA8PSBiTGVuZ3RoOyBqKyspIHtcbiAgICAgIGNvbnN0IGNvc3QgPSBhW2kgLSAxXSA9PT0gYltqIC0gMV0gPyAwIDogMTtcblxuICAgICAgZFtpXVtqXSA9IE1hdGgubWluKFxuICAgICAgICBkW2kgLSAxXVtqXSArIDEsXG4gICAgICAgIGRbaV1baiAtIDFdICsgMSxcbiAgICAgICAgZFtpIC0gMV1baiAtIDFdICsgY29zdCxcbiAgICAgICk7XG5cbiAgICAgIGlmIChpID4gMSAmJiBqID4gMSAmJiBhW2kgLSAxXSA9PT0gYltqIC0gMl0gJiYgYVtpIC0gMl0gPT09IGJbaiAtIDFdKSB7XG4gICAgICAgIGRbaV1bal0gPSBNYXRoLm1pbihkW2ldW2pdLCBkW2kgLSAyXVtqIC0gMl0gKyBjb3N0KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gZFthTGVuZ3RoXVtiTGVuZ3RoXTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldENsb3Nlc3RTdHJpbmcoZ2l2ZW4sIG90aGVycykge1xuICBpZiAoIW90aGVycyB8fCBvdGhlcnMubGVuZ3RoID09PSAwKSByZXR1cm4gbnVsbDtcbiAgbGV0IGJlc3RNYXRjaCA9IHtcbiAgICBzdHJpbmc6IG90aGVyc1swXSxcbiAgICBkaXN0YW5jZTogbGV4aWNhbERpc3RhbmNlKGdpdmVuLCBvdGhlcnNbMF0pLFxuICB9O1xuICBmb3IgKGxldCBpID0gMDsgaSA8IG90aGVycy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IGRpc3RhbmNlID0gbGV4aWNhbERpc3RhbmNlKGdpdmVuLCBvdGhlcnNbaV0pO1xuICAgIGJlc3RNYXRjaCA9IGRpc3RhbmNlIDwgYmVzdE1hdGNoLmRpc3RhbmNlID8ge1xuICAgICAgc3RyaW5nOiBvdGhlcnNbaV0sXG4gICAgICBkaXN0YW5jZSxcbiAgICB9IDogYmVzdE1hdGNoO1xuICB9XG5cbiAgaWYgKGJlc3RNYXRjaC5kaXN0YW5jZSA8PSA0KSByZXR1cm4gYmVzdE1hdGNoLnN0cmluZztcbiAgcmV0dXJuIG51bGw7XG59XG5cbmV4cG9ydCBjb25zdCBnZXRGaWxlID0gYXN5bmMgKGxpbmspID0+IHtcbiAgY29uc3QgcmVzcCA9IGF3YWl0IGZldGNoKGxpbmspO1xuICByZXR1cm4gcmVzcC50ZXh0KCk7XG59O1xuXG5leHBvcnQgZnVuY3Rpb24gaXNSZWYobm9kZSkge1xuICByZXR1cm4gbm9kZSAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobm9kZSwgJyRyZWYnKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGRlYm91bmNlKGZ1bmMsIHdhaXQsIGltbWVkaWF0ZSkge1xuICBsZXQgdGltZW91dDtcblxuICByZXR1cm4gZnVuY3Rpb24gZXhlY3V0ZWRGdW5jdGlvbiguLi5hcmdzKSB7XG4gICAgY29uc3QgY29udGV4dCA9IHRoaXM7XG5cbiAgICBjb25zdCBsYXRlciA9ICgpID0+IHtcbiAgICAgIHRpbWVvdXQgPSBudWxsO1xuICAgICAgaWYgKCFpbW1lZGlhdGUpIGZ1bmMuYXBwbHkoY29udGV4dCwgYXJncyk7XG4gICAgfTtcblxuICAgIGNvbnN0IGNhbGxOb3cgPSBpbW1lZGlhdGUgJiYgIXRpbWVvdXQ7XG5cbiAgICBjbGVhclRpbWVvdXQodGltZW91dCk7XG5cbiAgICB0aW1lb3V0ID0gc2V0VGltZW91dChsYXRlciwgd2FpdCk7XG5cbiAgICBpZiAoY2FsbE5vdykgZnVuYy5hcHBseShjb250ZXh0LCBhcmdzKTtcbiAgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG1hdGNoKHVybCwgcGF0dGVybikge1xuICBpZiAoIXBhdHRlcm4ubWF0Y2goL15odHRwcz86XFwvXFwvLykpIHtcbiAgICAvLyBpZiBwYXR0ZXJuIGRvZXNuJ3Qgc3BlY2lmeSBwcm90b2NvbCBkaXJlY3RseSwgZG8gbm90IG1hdGNoIGFnYWluc3QgaXRcbiAgICB1cmwgPSB1cmwucmVwbGFjZSgvXmh0dHBzPzpcXC9cXC8vLCAnJyk7XG4gIH1cbiAgcmV0dXJuIG1pbmltYXRjaCh1cmwsIHBhdHRlcm4pO1xufVxuXG4vLyB3ZSBpZ25vcmUgdGhpcyBhcyBpbiB0aGUgYmFkLXBhdGggd2UgZW5kIHVwIHdpdGggdGVybWluYXRpbmcgdGhlIHByb2Nlc3MuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgY29uc2lzdGVudC1yZXR1cm5cbmV4cG9ydCBmdW5jdGlvbiByZWFkWWFtbChmaWxlbmFtZSkge1xuICBsZXQgc291cmNlO1xuICB0cnkge1xuICAgIHNvdXJjZSA9IGZzLnJlYWRGaWxlU3luYyhmaWxlbmFtZSwgJ3V0Zi04Jyk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc3QgZGVmaW5pdGlvbnMgPSBnZXREZWZpbml0aW9uTmFtZXMoKTtcbiAgICBwcm9jZXNzLnN0ZGVyci53cml0ZShmaWxlTm90Rm91bmRFcnJvcihmaWxlbmFtZSwgZGVmaW5pdGlvbnMpKTtcbiAgICBwcm9jZXNzLmV4aXQoMSk7XG4gIH1cbiAgdHJ5IHtcbiAgICBjb25zdCBkb2N1bWVudCA9IHlhbWwuc2FmZUxvYWQoc291cmNlLCB7IGZpbGVuYW1lIH0pO1xuICAgIHJldHVybiB7XG4gICAgICBkb2N1bWVudCxcbiAgICAgIHNvdXJjZSxcbiAgICB9O1xuICB9IGNhdGNoIChleCkge1xuICAgIC8vIGNvbnNvbGUubG9nKGV4KTtcbiAgICBwcm9jZXNzLnN0ZGVyci53cml0ZShgQ2FuJ3QgbG9hZCB5YW1sIGZpbGUuIEVycm9yIGR1cmluZyBwYXJzaW5nIFlBTUwgc291cmNlOlxcbiR7ZXgubWVzc2FnZX1cXG5gKTtcbiAgICBwcm9jZXNzLmV4aXQoMSk7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGZpbGVOb3RGb3VuZEVycm9yKGZOYW1lLCBkZWZpbml0aW9ucykge1xuICBsZXQgZXJyb3JNZXNzYWdlID0gYENhbid0IGZpbmQgZGVmaW5pdGlvbiBvciBmaWxlIHdpdGggbmFtZTogJHtjaGFsay5yZWQoZk5hbWUpfS5cXG5gO1xuICBpZiAoZGVmaW5pdGlvbnMpIHtcbiAgICBlcnJvck1lc3NhZ2UgPSBgJHtlcnJvck1lc3NhZ2V9XFxuQXZhaWxhYmxlIGRlZmluaXRpb25zOlxcbi0gJHtkZWZpbml0aW9ucy5qb2luKCdcXG4tICcpfVxcbmA7XG4gIH1cbiAgcmV0dXJuIGVycm9yTWVzc2FnZTtcbn1cbiJdfQ==