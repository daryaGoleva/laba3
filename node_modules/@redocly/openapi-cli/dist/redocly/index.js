"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _fs = require("fs");

var _path = require("path");

var _os = require("os");

var _chalk = _interopRequireDefault(require("chalk"));

var _query = _interopRequireDefault(require("./query"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/* eslint-disable max-len */
const TOKEN_FILENAME = '.redocly-config.json';

class RedoclyClient {
  constructor() {
    this.loadToken();
  }

  hasToken() {
    return !!this.accessToken;
  }

  loadToken() {
    if (process.env.REDOCLY_AUTHORIZATION) {
      this.accessToken = process.env.REDOCLY_AUTHORIZATION;
      return;
    }

    const credentialsPath = (0, _path.resolve)((0, _os.homedir)(), TOKEN_FILENAME);

    if ((0, _fs.existsSync)(credentialsPath)) {
      const credentials = JSON.parse((0, _fs.readFileSync)(credentialsPath, 'utf-8'));
      this.accessToken = credentials && credentials.token;
    }
  }

  async isAuthorizedWithRedocly() {
    return this.hasToken() && !!(await this.getAuthorizationHeader());
  }

  async verifyToken(accessToken) {
    if (!accessToken) return false;
    const authDetails = await RedoclyClient.authorize(accessToken);
    if (!authDetails) return false;
    return true;
  }

  async getAuthorizationHeader() {
    // print this only if there is token but invalid
    if (this.accessToken && !(await this.verifyToken(this.accessToken))) {
      process.stdout.write(`${_chalk.default.yellow('Warning:')} invalid Redoc.ly access token. Use "npx @redocly/openapi-cli registry:login" to provide your access token\n`);
      return null;
    }

    return this.accessToken;
  }

  async login(accessToken) {
    const credentialsPath = (0, _path.resolve)((0, _os.homedir)(), TOKEN_FILENAME);
    process.stdout.write(_chalk.default.grey('\n  Logging in...\n'));
    const authorized = await this.verifyToken(accessToken);

    if (!authorized) {
      process.stdout.write(_chalk.default.red('Authorization failed. Please check if you entered a valid token.\n'));
      process.exit(1);
    }

    this.accessToken = accessToken;
    const credentials = {
      token: accessToken
    };
    (0, _fs.writeFileSync)(credentialsPath, JSON.stringify(credentials, null, 2));
    process.stdout.write(_chalk.default.green('  Authorization confirmed. ‚úÖ\n\n'));
  }

  logout() {
    const credentialsPath = (0, _path.resolve)((0, _os.homedir)(), TOKEN_FILENAME);

    if ((0, _fs.existsSync)(credentialsPath)) {
      (0, _fs.unlinkSync)(credentialsPath);
    }

    process.stdout.write('Logged out from the Redoc.ly account. ‚úã\n');
  }

  async query(queryString, parameters = {}, headers = {}) {
    return (0, _query.default)(queryString, parameters, {
      Authorization: this.accessToken,
      ...headers
    });
  }

  static async authorize(accessToken, verbose = false) {
    try {
      const result = await (0, _query.default)(`
      {
        definitions {
          id
        }
      }
      `, {}, {
        Authorization: accessToken
      });
      return result;
    } catch (e) {
      if (verbose) process.stderr.write(e);
      return null;
    }
  }

  async updateDependencies(dependencies) {
    const r = await this.query(`
    mutation UpdateBranchDependenciesFromURLs(
      $urls: [String!]!
      $definitionId: Int!
      $versionId: Int!
      $branchId: Int!
    ) {
      updateBranchDependenciesFromURLs(
        definitionId: $definitionId
        versionId: $versionId
        branchId: $branchId
        urls: $urls
      ) {
        branchName
      }
    }
    `, {
      urls: dependencies || [],
      definitionId: parseInt(process.env.DEFINITION, 10),
      versionId: parseInt(process.env.VERSION, 10),
      branchId: parseInt(process.env.BRANCH, 10)
    });
    return r;
  }

  static isRegistryURL(link) {
    const domain = process.env.REDOCLY_DOMAIN || 'redoc.ly';
    if (!link.startsWith(`https://api.${domain}/registry/`)) return false;
    const registryPath = link.replace(`https://api.${domain}/registry/`, '');
    const pathParts = registryPath.split('/'); // we can be sure, that there is job UUID present
    // (org, definition, version, bundle, branch, job, "openapi.yaml" ü§¶‚Äç‚ôÇÔ∏è)
    // so skip this link.

    if (pathParts.length === 7) return false;
    return true;
  }

}

exports.default = RedoclyClient;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9yZWRvY2x5L2luZGV4LmpzIl0sIm5hbWVzIjpbIlRPS0VOX0ZJTEVOQU1FIiwiUmVkb2NseUNsaWVudCIsImNvbnN0cnVjdG9yIiwibG9hZFRva2VuIiwiaGFzVG9rZW4iLCJhY2Nlc3NUb2tlbiIsInByb2Nlc3MiLCJlbnYiLCJSRURPQ0xZX0FVVEhPUklaQVRJT04iLCJjcmVkZW50aWFsc1BhdGgiLCJjcmVkZW50aWFscyIsIkpTT04iLCJwYXJzZSIsInRva2VuIiwiaXNBdXRob3JpemVkV2l0aFJlZG9jbHkiLCJnZXRBdXRob3JpemF0aW9uSGVhZGVyIiwidmVyaWZ5VG9rZW4iLCJhdXRoRGV0YWlscyIsImF1dGhvcml6ZSIsInN0ZG91dCIsIndyaXRlIiwiY2hhbGsiLCJ5ZWxsb3ciLCJsb2dpbiIsImdyZXkiLCJhdXRob3JpemVkIiwicmVkIiwiZXhpdCIsInN0cmluZ2lmeSIsImdyZWVuIiwibG9nb3V0IiwicXVlcnkiLCJxdWVyeVN0cmluZyIsInBhcmFtZXRlcnMiLCJoZWFkZXJzIiwiQXV0aG9yaXphdGlvbiIsInZlcmJvc2UiLCJyZXN1bHQiLCJlIiwic3RkZXJyIiwidXBkYXRlRGVwZW5kZW5jaWVzIiwiZGVwZW5kZW5jaWVzIiwiciIsInVybHMiLCJkZWZpbml0aW9uSWQiLCJwYXJzZUludCIsIkRFRklOSVRJT04iLCJ2ZXJzaW9uSWQiLCJWRVJTSU9OIiwiYnJhbmNoSWQiLCJCUkFOQ0giLCJpc1JlZ2lzdHJ5VVJMIiwibGluayIsImRvbWFpbiIsIlJFRE9DTFlfRE9NQUlOIiwic3RhcnRzV2l0aCIsInJlZ2lzdHJ5UGF0aCIsInJlcGxhY2UiLCJwYXRoUGFydHMiLCJzcGxpdCIsImxlbmd0aCJdLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUNBOztBQUdBOztBQUNBOztBQUNBOztBQUVBOzs7O0FBUkE7QUFVQSxNQUFNQSxjQUFjLEdBQUcsc0JBQXZCOztBQUVlLE1BQU1DLGFBQU4sQ0FBb0I7QUFDakNDLEVBQUFBLFdBQVcs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QUFPUixDQUFQO0FBQ0Q7O0FBRUQsU0FBT1MsYUFBUCxDQUFxQkMsSUFBckIsRUFBMkI7QUFDekIsVUFBTUMsTUFBTSxHQUFHL0MsT0FBTyxDQUFDQyxHQUFSLENBQVkrQyxjQUFaLElBQThCLFVBQTdDO0FBQ0EsUUFBSSxDQUFDRixJQUFJLENBQUNHLFVBQUwsQ0FBaUIsZUFBY0YsTUFBTyxZQUF0QyxDQUFMLEVBQXlELE9BQU8sS0FBUDtBQUN6RCxVQUFNRyxZQUFZLEdBQUdKLElBQUksQ0FBQ0ssT0FBTCxDQUFjLGVBQWNKLE1BQU8sWUFBbkMsRUFBZ0QsRUFBaEQsQ0FBckI7QUFFQSxVQUFNSyxTQUFTLEdBQUdGLFlBQVksQ0FBQ0csS0FBYixDQUFtQixHQUFuQixDQUFsQixDQUx5QixDQU96QjtBQUNBO0FBQ0E7O0FBQ0EsUUFBSUQsU0FBUyxDQUFDRSxNQUFWLEtBQXFCLENBQXpCLEVBQTRCLE9BQU8sS0FBUDtBQUU1QixXQUFPLElBQVA7QUFDRDs7QUE1SWdDIiwic291cmNlc0NvbnRlbnQiOlsiLyogZXNsaW50LWRpc2FibGUgbWF4LWxlbiAqL1xuaW1wb3J0IHtcbiAgZXhpc3RzU3luYywgcmVhZEZpbGVTeW5jLCB3cml0ZUZpbGVTeW5jLCB1bmxpbmtTeW5jLFxufSBmcm9tICdmcyc7XG5pbXBvcnQgeyByZXNvbHZlIH0gZnJvbSAncGF0aCc7XG5pbXBvcnQgeyBob21lZGlyIH0gZnJvbSAnb3MnO1xuaW1wb3J0IGNoYWxrIGZyb20gJ2NoYWxrJztcblxuaW1wb3J0IHF1ZXJ5IGZyb20gJy4vcXVlcnknO1xuXG5jb25zdCBUT0tFTl9GSUxFTkFNRSA9ICcucmVkb2NseS1jb25maWcuanNvbic7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFJlZG9jbHlDbGllbnQge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLmxvYWRUb2tlbigpO1xuICB9XG5cbiAgaGFzVG9rZW4oKSB7XG4gICAgcmV0dXJuICEhdGhpcy5hY2Nlc3NUb2tlbjtcbiAgfVxuXG4gIGxvYWRUb2tlbigpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuUkVET0NMWV9BVVRIT1JJWkFUSU9OKSB7XG4gICAgICB0aGlzLmFjY2Vzc1Rva2VuID0gcHJvY2Vzcy5lbnYuUkVET0NMWV9BVVRIT1JJWkFUSU9OO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IGNyZWRlbnRpYWxzUGF0aCA9IHJlc29sdmUoaG9tZWRpcigpLCBUT0tFTl9GSUxFTkFNRSk7XG4gICAgaWYgKGV4aXN0c1N5bmMoY3JlZGVudGlhbHNQYXRoKSkge1xuICAgICAgY29uc3QgY3JlZGVudGlhbHMgPSBKU09OLnBhcnNlKHJlYWRGaWxlU3luYyhjcmVkZW50aWFsc1BhdGgsICd1dGYtOCcpKTtcbiAgICAgIHRoaXMuYWNjZXNzVG9rZW4gPSBjcmVkZW50aWFscyAmJiBjcmVkZW50aWFscy50b2tlbjtcbiAgICB9XG4gIH1cblxuICBhc3luYyBpc0F1dGhvcml6ZWRXaXRoUmVkb2NseSgpIHtcbiAgICByZXR1cm4gdGhpcy5oYXNUb2tlbigpICYmICEhKGF3YWl0IHRoaXMuZ2V0QXV0aG9yaXphdGlvbkhlYWRlcigpKTtcbiAgfVxuXG4gIGFzeW5jIHZlcmlmeVRva2VuKGFjY2Vzc1Rva2VuKSB7XG4gICAgaWYgKCFhY2Nlc3NUb2tlbikgcmV0dXJuIGZhbHNlO1xuICAgIGNvbnN0IGF1dGhEZXRhaWxzID0gYXdhaXQgUmVkb2NseUNsaWVudC5hdXRob3JpemUoYWNjZXNzVG9rZW4pO1xuICAgIGlmICghYXV0aERldGFpbHMpIHJldHVybiBmYWxzZTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGFzeW5jIGdldEF1dGhvcml6YXRpb25IZWFkZXIoKSB7XG4gICAgLy8gcHJpbnQgdGhpcyBvbmx5IGlmIHRoZXJlIGlzIHRva2VuIGJ1dCBpbnZhbGlkXG4gICAgaWYgKHRoaXMuYWNjZXNzVG9rZW4gJiYgIShhd2FpdCB0aGlzLnZlcmlmeVRva2VuKHRoaXMuYWNjZXNzVG9rZW4pKSkge1xuICAgICAgcHJvY2Vzcy5zdGRvdXQud3JpdGUoXG4gICAgICAgIGAke2NoYWxrLnllbGxvdygnV2FybmluZzonKX0gaW52YWxpZCBSZWRvYy5seSBhY2Nlc3MgdG9rZW4uIFVzZSBcIm5weCBAcmVkb2NseS9vcGVuYXBpLWNsaSByZWdpc3RyeTpsb2dpblwiIHRvIHByb3ZpZGUgeW91ciBhY2Nlc3MgdG9rZW5cXG5gLFxuICAgICAgKTtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5hY2Nlc3NUb2tlbjtcbiAgfVxuXG4gIGFzeW5jIGxvZ2luKGFjY2Vzc1Rva2VuKSB7XG4gICAgY29uc3QgY3JlZGVudGlhbHNQYXRoID0gcmVzb2x2ZShob21lZGlyKCksIFRPS0VOX0ZJTEVOQU1FKTtcbiAgICBwcm9jZXNzLnN0ZG91dC53cml0ZShjaGFsay5ncmV5KCdcXG4gIExvZ2dpbmcgaW4uLi5cXG4nKSk7XG5cbiAgICBjb25zdCBhdXRob3JpemVkID0gYXdhaXQgdGhpcy52ZXJpZnlUb2tlbihhY2Nlc3NUb2tlbik7XG5cbiAgICBpZiAoIWF1dGhvcml6ZWQpIHtcbiAgICAgIHByb2Nlc3Muc3Rkb3V0LndyaXRlKGNoYWxrLnJlZCgnQXV0aG9yaXphdGlvbiBmYWlsZWQuIFBsZWFzZSBjaGVjayBpZiB5b3UgZW50ZXJlZCBhIHZhbGlkIHRva2VuLlxcbicpKTtcbiAgICAgIHByb2Nlc3MuZXhpdCgxKTtcbiAgICB9XG5cbiAgICB0aGlzLmFjY2Vzc1Rva2VuID0gYWNjZXNzVG9rZW47XG4gICAgY29uc3QgY3JlZGVudGlhbHMgPSB7XG4gICAgICB0b2tlbjogYWNjZXNzVG9rZW4sXG4gICAgfTtcblxuICAgIHdyaXRlRmlsZVN5bmMoY3JlZGVudGlhbHNQYXRoLCBKU09OLnN0cmluZ2lmeShjcmVkZW50aWFscywgbnVsbCwgMikpO1xuICAgIHByb2Nlc3Muc3Rkb3V0LndyaXRlKGNoYWxrLmdyZWVuKCcgIEF1dGhvcml6YXRpb24gY29uZmlybWVkLiDinIVcXG5cXG4nKSk7XG4gIH1cblxuICBsb2dvdXQoKSB7XG4gICAgY29uc3QgY3JlZGVudGlhbHNQYXRoID0gcmVzb2x2ZShob21lZGlyKCksIFRPS0VOX0ZJTEVOQU1FKTtcbiAgICBpZiAoZXhpc3RzU3luYyhjcmVkZW50aWFsc1BhdGgpKSB7XG4gICAgICB1bmxpbmtTeW5jKGNyZWRlbnRpYWxzUGF0aCk7XG4gICAgfVxuICAgIHByb2Nlc3Muc3Rkb3V0LndyaXRlKCdMb2dnZWQgb3V0IGZyb20gdGhlIFJlZG9jLmx5IGFjY291bnQuIOKci1xcbicpO1xuICB9XG5cbiAgYXN5bmMgcXVlcnkocXVlcnlTdHJpbmcsIHBhcmFtZXRlcnMgPSB7fSwgaGVhZGVycyA9IHt9KSB7XG4gICAgcmV0dXJuIHF1ZXJ5KHF1ZXJ5U3RyaW5nLCBwYXJhbWV0ZXJzLFxuICAgICAge1xuICAgICAgICBBdXRob3JpemF0aW9uOiB0aGlzLmFjY2Vzc1Rva2VuLFxuICAgICAgICAuLi5oZWFkZXJzLFxuICAgICAgfSk7XG4gIH1cblxuICBzdGF0aWMgYXN5bmMgYXV0aG9yaXplKGFjY2Vzc1Rva2VuLCB2ZXJib3NlID0gZmFsc2UpIHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcXVlcnkoYFxuICAgICAge1xuICAgICAgICBkZWZpbml0aW9ucyB7XG4gICAgICAgICAgaWRcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgYCxcbiAgICAgIHt9LFxuICAgICAge1xuICAgICAgICBBdXRob3JpemF0aW9uOiBhY2Nlc3NUb2tlbixcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBpZiAodmVyYm9zZSkgcHJvY2Vzcy5zdGRlcnIud3JpdGUoZSk7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH1cblxuICBhc3luYyB1cGRhdGVEZXBlbmRlbmNpZXMoZGVwZW5kZW5jaWVzKSB7XG4gICAgY29uc3QgciA9IGF3YWl0IHRoaXMucXVlcnkoYFxuICAgIG11dGF0aW9uIFVwZGF0ZUJyYW5jaERlcGVuZGVuY2llc0Zyb21VUkxzKFxuICAgICAgJHVybHM6IFtTdHJpbmchXSFcbiAgICAgICRkZWZpbml0aW9uSWQ6IEludCFcbiAgICAgICR2ZXJzaW9uSWQ6IEludCFcbiAgICAgICRicmFuY2hJZDogSW50IVxuICAgICkge1xuICAgICAgdXBkYXRlQnJhbmNoRGVwZW5kZW5jaWVzRnJvbVVSTHMoXG4gICAgICAgIGRlZmluaXRpb25JZDogJGRlZmluaXRpb25JZFxuICAgICAgICB2ZXJzaW9uSWQ6ICR2ZXJzaW9uSWRcbiAgICAgICAgYnJhbmNoSWQ6ICRicmFuY2hJZFxuICAgICAgICB1cmxzOiAkdXJsc1xuICAgICAgKSB7XG4gICAgICAgIGJyYW5jaE5hbWVcbiAgICAgIH1cbiAgICB9XG4gICAgYCxcbiAgICB7XG4gICAgICB1cmxzOiBkZXBlbmRlbmNpZXMgfHwgW10sXG4gICAgICBkZWZpbml0aW9uSWQ6IHBhcnNlSW50KHByb2Nlc3MuZW52LkRFRklOSVRJT04sIDEwKSxcbiAgICAgIHZlcnNpb25JZDogcGFyc2VJbnQocHJvY2Vzcy5lbnYuVkVSU0lPTiwgMTApLFxuICAgICAgYnJhbmNoSWQ6IHBhcnNlSW50KHByb2Nlc3MuZW52LkJSQU5DSCwgMTApLFxuICAgIH0pO1xuICAgIHJldHVybiByO1xuICB9XG5cbiAgc3RhdGljIGlzUmVnaXN0cnlVUkwobGluaykge1xuICAgIGNvbnN0IGRvbWFpbiA9IHByb2Nlc3MuZW52LlJFRE9DTFlfRE9NQUlOIHx8ICdyZWRvYy5seSc7XG4gICAgaWYgKCFsaW5rLnN0YXJ0c1dpdGgoYGh0dHBzOi8vYXBpLiR7ZG9tYWlufS9yZWdpc3RyeS9gKSkgcmV0dXJuIGZhbHNlO1xuICAgIGNvbnN0IHJlZ2lzdHJ5UGF0aCA9IGxpbmsucmVwbGFjZShgaHR0cHM6Ly9hcGkuJHtkb21haW59L3JlZ2lzdHJ5L2AsICcnKTtcblxuICAgIGNvbnN0IHBhdGhQYXJ0cyA9IHJlZ2lzdHJ5UGF0aC5zcGxpdCgnLycpO1xuXG4gICAgLy8gd2UgY2FuIGJlIHN1cmUsIHRoYXQgdGhlcmUgaXMgam9iIFVVSUQgcHJlc2VudFxuICAgIC8vIChvcmcsIGRlZmluaXRpb24sIHZlcnNpb24sIGJ1bmRsZSwgYnJhbmNoLCBqb2IsIFwib3BlbmFwaS55YW1sXCIg8J+kpuKAjeKZgu+4jylcbiAgICAvLyBzbyBza2lwIHRoaXMgbGluay5cbiAgICBpZiAocGF0aFBhcnRzLmxlbmd0aCA9PT0gNykgcmV0dXJuIGZhbHNlO1xuXG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbn1cbiJdfQ==