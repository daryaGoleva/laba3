"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.popPath = popPath;
exports.resolveNodeNoSideEffects = resolveNodeNoSideEffects;
exports.default = void 0;

var _fs = _interopRequireDefault(require("fs"));

var _jsYaml = _interopRequireDefault(require("js-yaml"));

var _path = require("path");

var _url = require("url");

var _nodeFetch = _interopRequireDefault(require("node-fetch"));

var _error = _interopRequireWildcard(require("./error"));

var _utils = require("./utils");

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function pushPath(ctx, filePath, docPath) {
  ctx.pathStack.push({
    path: ctx.path,
    file: ctx.filePath,
    document: ctx.document,
    source: ctx.source
  });
  ctx.path = docPath;
  ctx.filePath = filePath;
}

function decodePointerComponent(component) {
  return component.replace(/~1/g, '/').replace(/~0/g, '~');
}

function popPath(ctx) {
  const topPath = ctx.pathStack.pop();
  ctx.path = topPath.path;
  ctx.filePath = topPath.file;
  ctx.source = topPath.source;
  ctx.document = topPath.document;
}
/**
 *
 * Here we go over each of the steps in the link and try to retreive the value
 * for it. If failed (e.g. because of undefined value) -- return null, to indicate that such
 * reference does not exist.
 *
 * TODO: we might need a feature to support validation of "URL" based definitions in the future, so
 * would be nice to have opportunity to call resolve() with empty ctx.
 *
 * TODO: add per-file/per-url cache
 *
 * @param {string} link A path in the yaml document which is to be resolved
 * @param {*} ctx JSON Object with the document field which represents the YAML structure
 */


async function resolve(link, ctx, visited = []) {
  const linkSplitted = link.split('#/');
  if (linkSplitted[0] === '') linkSplitted[0] = ctx.filePath;
  const [filePath, docPath] = linkSplitted;
  const resolvedFilePath = (0, _utils.isFullyQualifiedUrl)(ctx.filePath) || (0, _utils.isFullyQualifiedUrl)(filePath) ? (0, _url.resolve)(ctx.filePath, filePath) : (0, _path.resolve)((0, _path.dirname)(ctx.filePath), filePath);
  let document;
  let source;
  const isCurrentDocument = resolvedFilePath === ctx.filePath;
  pushPath(ctx, resolvedFilePath, []);
  const resolvedLink = `${resolvedFilePath}#/${docPath}`;

  if (!isCurrentDocument) {
    if (ctx.resolveCache[resolvedFilePath]) {
      ({
        source,
        document
      } = ctx.resolveCache[resolvedFilePath]);
    } else if (_fs.default.existsSync(resolvedFilePath)) {
      ctx.fileDependencies.add(resolvedFilePath); // FIXME: if refernced e.g. md file, no need to parse

      source = _fs.default.readFileSync(resolvedFilePath, 'utf-8');

      try {
        document = _jsYaml.default.safeLoad(source);
      } catch (e) {
        ctx.result.push((0, _error.createYAMLParseError)(e, ctx, resolvedFilePath, source));
        return {
          node: undefined
        };
      }
    } else if ((0, _utils.isFullyQualifiedUrl)(resolvedFilePath)) {
      try {
        const headers = {};

        for (let i = 0; i < ctx.headers.length; i++) {
          if ((0, _utils.match)(resolvedFilePath, ctx.headers[i].matches)) {
            headers[ctx.headers[i].name] = ctx.headers[i].value;
          }
        }

        const req = await (0, _nodeFetch.default)(resolvedFilePath, {
          headers
        });

        if (!req.ok) {
          return {
            node: undefined
          };
        }

        const text = await req.text();

        try {
          source = text;
          document = _jsYaml.default.safeLoad(text);
        } catch (e) {
          ctx.result.push((0, _error.createYAMLParseError)(e, ctx, resolvedFilePath, source));
          return {
            node: undefined
          };
        }
      } catch (e) {
        // FIXME: lost yaml parsing errors and network errors here
        return {
          node: undefined
        };
      }
    } else {
      return {
        node: undefined
      };
    }
  } else {
    document = ctx.document;
    source = ctx.source;
  }

  if (source) ctx.resolveCache[resolvedFilePath] = {
    source,
    document
  };
  ctx.source = source;
  ctx.document = document;
  const docPathSteps = docPath ? docPath.split('/').filter(el => el !== '').reverse() : [];
  let target = document;
  let circular;
  let transitiveResolvesOnStack = 0;
  let transitiveError;

  if (visited.indexOf(resolvedLink) > -1) {
    target = undefined;
    circular = true;
  }

  visited.push(resolvedLink);

  while (target !== undefined) {
    if (target && target.$ref) {
      // handle transitive $ref's
      const resolved = await resolve(target.$ref, ctx, visited);
      transitiveError = resolved.transitiveError;

      if (resolved.node === undefined && !transitiveError) {
        // We want to show only the error for the first $ref that can't be resolved.
        // So we create it on the current stack and propagate it out as a transitiveError
        popPath(ctx);
        ctx.path.push('$ref');
        const message = resolved.circular ? 'Circular reference.' : 'Reference does not exist.';
        transitiveError = (0, _error.default)(message, target, ctx, {
          fromRule: 'resolve-ref'
        });
        ctx.path.pop();
        target = undefined;
        break;
      }

      target = resolved.node;
      transitiveResolvesOnStack++;
    }

    let step = docPathSteps.pop();
    if (!step) break;
    step = decodePointerComponent(step);
    target = target && target[step] !== undefined ? target[step] : undefined;
    ctx.path.push(step);
  }

  for (let i = 0; i < transitiveResolvesOnStack; ++i) {
    // keep current file context and remove indirection records
    ctx.pathStack.pop();
  }

  if (transitiveError) {
    // recalc referencedFrom after exiting transitive ref stack to show original $ref in the error
    transitiveError.referencedFrom = (0, _error.getReferencedFrom)(ctx);
  }

  return {
    node: target,
    transitiveError,
    circular
  };
}
/*
 * This function is used to resolve $ref fields inside the node. Currently supports links:
 * - inside the file
 * - to the another file in local file system
 * - http(s) links to other files
 *
 * $ref field value must be a valid OpenAPI link
 * (e.g. another/dir/file.yaml#/components/schemas/Example)
 *
 * @param {*} node
 * @param {*} ctx
 */


async function resolveNode(node, ctx) {
  if (!node || typeof node !== 'object') return {
    node
  };

  if (node.$ref) {
    const resolved = await resolve(node.$ref, ctx);

    if (resolved.node === undefined) {
      // can't resolve
      popPath(ctx);
      ctx.path.push('$ref');
      const error = resolved.transitiveError ? resolved.transitiveError : (0, _error.default)('Reference does not exist.', node, ctx, {
        fromRule: 'resolve-ref'
      });
      ctx.path.pop();
      ctx.result.push(error);
      return {
        node
      };
    }

    return {
      node: resolved.node,
      onStack: true
    };
  }

  return {
    node
  };
} // to be used in mutators


async function resolveNodeNoSideEffects(node, ctx) {
  const ctxCopy = { ...ctx,
    pathStack: ctx.pathStack.slice()
  };
  return resolveNode(node, ctxCopy);
}

var _default = resolveNode;
exports.default = _default;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9yZXNvbHZlci5qcyJdLCJuYW1lcyI6WyJwdXNoUGF0aCIsImN0eCIsImZpbGVQYXRoIiwiZG9jUGF0aCIsInBhdGhTdGFjayIsInB1c2giLCJwYXRoIiwiZmlsZSIsImRvY3VtZW50Iiwic291cmNlIiwiZGVjb2RlUG9pbnRlckNvbXBvbmVudCIsImNvbXBvbmVudCIsInJlcGxhY2UiLCJwb3BQYXRoIiwidG9wUGF0aCIsInBvcCIsInJlc29sdmUiLCJsaW5rIiwidmlzaXRlZCIsImxpbmtTcGxpdHRlZCIsInNwbGl0IiwicmVzb2x2ZWRGaWxlUGF0aCIsImlzQ3VycmVudERvY3VtZW50IiwicmVzb2x2ZWRMaW5rIiwicmVzb2x2ZUNhY2hlIiwiZnMiLCJleGlzdHNTeW5jIiwiZmlsZURlcGVuZGVuY2llcyIsImFkZCIsInJlYWRGaWxlU3luYyIsInlhbWwiLCJzYWZlTG9hZCIsImUiLCJyZXN1bHQiLCJub2RlIiwidW5kZWZpbmVkIiwiaGVhZGVycyIsImkiLCJsZW5ndGgiLCJtYXRjaGVzIiwibmFtZSIsInZhbHVlIiwicmVxIiwib2siLCJ0ZXh0IiwiZG9jUGF0aFN0ZXBzIiwiZmlsdGVyIiwiZWwiLCJyZXZlcnNlIiwidGFyZ2V0IiwiY2lyY3VsYXIiLCJ0cmFuc2l0aXZlUmVzb2x2ZXNPblN0YWNrIiwidHJhbnNpdGl2ZUVycm9yIiwiaW5kZXhPZiIsIiRyZWYiLCJyZXNvbHZlZCIsIm1lc3NhZ2UiLCJmcm9tUnVsZSIsInN0ZXAiLCJyZWZlcmVuY2VkRnJvbSIsInJlc29sdmVOb2RlIiwiZXJyb3IiLCJvblN0YWNrIiwicmVzb2x2ZU5vZGVOb1NpZGVFZmZlY3RzIiwiY3R4Q29weSIsInNsaWNlIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBQTs7QUFFQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFFQTs7QUFDQTs7Ozs7Ozs7QUFFQSxTQUFTQSxRQUFULENBQWtCQyxHQUFsQixFQUF1QkMsUUFBdkIsRUFBaUNDLE9BQWpDLEVBQTBDO0FB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RUFBLE1BQUFBLEdBQUcsQ0FBQ0ssSUFBSixDQUFTRCxJQUFULENBQWMsTUFBZDtBQUNBLFlBQU13RCxLQUFLLEdBQUdOLFFBQVEsQ0FBQ0gsZUFBVCxHQUNWRyxRQUFRLENBQUNILGVBREMsR0FFVixvQkFBWSwyQkFBWixFQUF5Q2xCLElBQXpDLEVBQStDakMsR0FBL0MsRUFBb0Q7QUFBRXdELFFBQUFBLFFBQVEsRUFBRTtBQUFaLE9BQXBELENBRko7QUFHQXhELE1BQUFBLEdBQUcsQ0FBQ0ssSUFBSixDQUFTUyxHQUFUO0FBRUFkLE1BQUFBLEdBQUcsQ0FBQ2dDLE1BQUosQ0FBVzVCLElBQVgsQ0FBZ0J3RCxLQUFoQjtBQUVBLGFBQU87QUFBRTNCLFFBQUFBO0FBQUYsT0FBUDtBQUNEOztBQUVELFdBQU87QUFBRUEsTUFBQUEsSUFBSSxFQUFFcUIsUUFBUSxDQUFDckIsSUFBakI7QUFBdUI0QixNQUFBQSxPQUFPLEVBQUU7QUFBaEMsS0FBUDtBQUNEOztBQUVELFNBQU87QUFBRTVCLElBQUFBO0FBQUYsR0FBUDtBQUNELEMsQ0FFRDs7O0FBQ08sZUFBZTZCLHdCQUFmLENBQXdDN0IsSUFBeEMsRUFBOENqQyxHQUE5QyxFQUFtRDtBQUN4RCxRQUFNK0QsT0FBTyxHQUFHLEVBQUUsR0FBRy9ELEdBQUw7QUFBVUcsSUFBQUEsU0FBUyxFQUFFSCxHQUFHLENBQUNHLFNBQUosQ0FBYzZELEtBQWQ7QUFBckIsR0FBaEI7QUFDQSxTQUFPTCxXQUFXLENBQUMxQixJQUFELEVBQU84QixPQUFQLENBQWxCO0FBQ0Q7O2VBRWNKLFciLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgZnMgZnJvbSAnZnMnO1xuXG5pbXBvcnQgeWFtbCBmcm9tICdqcy15YW1sJztcbmltcG9ydCB7IHJlc29sdmUgYXMgcmVzb2x2ZUZpbGUsIGRpcm5hbWUgfSBmcm9tICdwYXRoJztcbmltcG9ydCB7IHJlc29sdmUgYXMgcmVzb2x2ZVVybCB9IGZyb20gJ3VybCc7XG5pbXBvcnQgZmV0Y2ggZnJvbSAnbm9kZS1mZXRjaCc7XG5cbmltcG9ydCBjcmVhdGVFcnJvciwgeyBnZXRSZWZlcmVuY2VkRnJvbSwgY3JlYXRlWUFNTFBhcnNlRXJyb3IgfSBmcm9tICcuL2Vycm9yJztcbmltcG9ydCB7IGlzRnVsbHlRdWFsaWZpZWRVcmwsIG1hdGNoIH0gZnJvbSAnLi91dGlscyc7XG5cbmZ1bmN0aW9uIHB1c2hQYXRoKGN0eCwgZmlsZVBhdGgsIGRvY1BhdGgpIHtcbiAgY3R4LnBhdGhTdGFjay5wdXNoKHtcbiAgICBwYXRoOiBjdHgucGF0aCwgZmlsZTogY3R4LmZpbGVQYXRoLCBkb2N1bWVudDogY3R4LmRvY3VtZW50LCBzb3VyY2U6IGN0eC5zb3VyY2UsXG4gIH0pO1xuXG4gIGN0eC5wYXRoID0gZG9jUGF0aDtcbiAgY3R4LmZpbGVQYXRoID0gZmlsZVBhdGg7XG59XG5cbmZ1bmN0aW9uIGRlY29kZVBvaW50ZXJDb21wb25lbnQoY29tcG9uZW50KSB7XG4gIHJldHVybiBjb21wb25lbnQucmVwbGFjZSgvfjEvZywgJy8nKS5yZXBsYWNlKC9+MC9nLCAnficpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcG9wUGF0aChjdHgpIHtcbiAgY29uc3QgdG9wUGF0aCA9IGN0eC5wYXRoU3RhY2sucG9wKCk7XG4gIGN0eC5wYXRoID0gdG9wUGF0aC5wYXRoO1xuICBjdHguZmlsZVBhdGggPSB0b3BQYXRoLmZpbGU7XG4gIGN0eC5zb3VyY2UgPSB0b3BQYXRoLnNvdXJjZTtcbiAgY3R4LmRvY3VtZW50ID0gdG9wUGF0aC5kb2N1bWVudDtcbn1cblxuLyoqXG4gKlxuICogSGVyZSB3ZSBnbyBvdmVyIGVhY2ggb2YgdGhlIHN0ZXBzIGluIHRoZSBsaW5rIGFuZCB0cnkgdG8gcmV0cmVpdmUgdGhlIHZhbHVlXG4gKiBmb3IgaXQuIElmIGZhaWxlZCAoZS5nLiBiZWNhdXNlIG9mIHVuZGVmaW5lZCB2YWx1ZSkgLS0gcmV0dXJuIG51bGwsIHRvIGluZGljYXRlIHRoYXQgc3VjaFxuICogcmVmZXJlbmNlIGRvZXMgbm90IGV4aXN0LlxuICpcbiAqIFRPRE86IHdlIG1pZ2h0IG5lZWQgYSBmZWF0dXJlIHRvIHN1cHBvcnQgdmFsaWRhdGlvbiBvZiBcIlVSTFwiIGJhc2VkIGRlZmluaXRpb25zIGluIHRoZSBmdXR1cmUsIHNvXG4gKiB3b3VsZCBiZSBuaWNlIHRvIGhhdmUgb3Bwb3J0dW5pdHkgdG8gY2FsbCByZXNvbHZlKCkgd2l0aCBlbXB0eSBjdHguXG4gKlxuICogVE9ETzogYWRkIHBlci1maWxlL3Blci11cmwgY2FjaGVcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gbGluayBBIHBhdGggaW4gdGhlIHlhbWwgZG9jdW1lbnQgd2hpY2ggaXMgdG8gYmUgcmVzb2x2ZWRcbiAqIEBwYXJhbSB7Kn0gY3R4IEpTT04gT2JqZWN0IHdpdGggdGhlIGRvY3VtZW50IGZpZWxkIHdoaWNoIHJlcHJlc2VudHMgdGhlIFlBTUwgc3RydWN0dXJlXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIHJlc29sdmUobGluaywgY3R4LCB2aXNpdGVkID0gW10pIHtcbiAgY29uc3QgbGlua1NwbGl0dGVkID0gbGluay5zcGxpdCgnIy8nKTtcbiAgaWYgKGxpbmtTcGxpdHRlZFswXSA9PT0gJycpIGxpbmtTcGxpdHRlZFswXSA9IGN0eC5maWxlUGF0aDtcbiAgY29uc3QgW2ZpbGVQYXRoLCBkb2NQYXRoXSA9IGxpbmtTcGxpdHRlZDtcblxuICBjb25zdCByZXNvbHZlZEZpbGVQYXRoID0gKGlzRnVsbHlRdWFsaWZpZWRVcmwoY3R4LmZpbGVQYXRoKSB8fCBpc0Z1bGx5UXVhbGlmaWVkVXJsKGZpbGVQYXRoKSlcbiAgICA/IHJlc29sdmVVcmwoY3R4LmZpbGVQYXRoLCBmaWxlUGF0aClcbiAgICA6IHJlc29sdmVGaWxlKGRpcm5hbWUoY3R4LmZpbGVQYXRoKSwgZmlsZVBhdGgpO1xuXG4gIGxldCBkb2N1bWVudDtcbiAgbGV0IHNvdXJjZTtcblxuICBjb25zdCBpc0N1cnJlbnREb2N1bWVudCA9IHJlc29sdmVkRmlsZVBhdGggPT09IGN0eC5maWxlUGF0aDtcblxuICBwdXNoUGF0aChjdHgsIHJlc29sdmVkRmlsZVBhdGgsIFtdKTtcblxuICBjb25zdCByZXNvbHZlZExpbmsgPSBgJHtyZXNvbHZlZEZpbGVQYXRofSMvJHtkb2NQYXRofWA7XG5cbiAgaWYgKCFpc0N1cnJlbnREb2N1bWVudCkge1xuICAgIGlmIChjdHgucmVzb2x2ZUNhY2hlW3Jlc29sdmVkRmlsZVBhdGhdKSB7XG4gICAgICAoeyBzb3VyY2UsIGRvY3VtZW50IH0gPSBjdHgucmVzb2x2ZUNhY2hlW3Jlc29sdmVkRmlsZVBhdGhdKTtcbiAgICB9IGVsc2UgaWYgKGZzLmV4aXN0c1N5bmMocmVzb2x2ZWRGaWxlUGF0aCkpIHtcbiAgICAgIGN0eC5maWxlRGVwZW5kZW5jaWVzLmFkZChyZXNvbHZlZEZpbGVQYXRoKTtcbiAgICAgIC8vIEZJWE1FOiBpZiByZWZlcm5jZWQgZS5nLiBtZCBmaWxlLCBubyBuZWVkIHRvIHBhcnNlXG4gICAgICBzb3VyY2UgPSBmcy5yZWFkRmlsZVN5bmMocmVzb2x2ZWRGaWxlUGF0aCwgJ3V0Zi04Jyk7XG4gICAgICB0cnkge1xuICAgICAgICBkb2N1bWVudCA9IHlhbWwuc2FmZUxvYWQoc291cmNlKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY3R4LnJlc3VsdC5wdXNoKGNyZWF0ZVlBTUxQYXJzZUVycm9yKGUsIGN0eCwgcmVzb2x2ZWRGaWxlUGF0aCwgc291cmNlKSk7XG4gICAgICAgIHJldHVybiB7IG5vZGU6IHVuZGVmaW5lZCB9O1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoaXNGdWxseVF1YWxpZmllZFVybChyZXNvbHZlZEZpbGVQYXRoKSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgaGVhZGVycyA9IHt9O1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGN0eC5oZWFkZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgaWYgKG1hdGNoKHJlc29sdmVkRmlsZVBhdGgsIGN0eC5oZWFkZXJzW2ldLm1hdGNoZXMpKSB7XG4gICAgICAgICAgICBoZWFkZXJzW2N0eC5oZWFkZXJzW2ldLm5hbWVdID0gY3R4LmhlYWRlcnNbaV0udmFsdWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgcmVxID0gYXdhaXQgZmV0Y2gocmVzb2x2ZWRGaWxlUGF0aCwgeyBoZWFkZXJzIH0pO1xuXG4gICAgICAgIGlmICghcmVxLm9rKSB7XG4gICAgICAgICAgcmV0dXJuIHsgbm9kZTogdW5kZWZpbmVkIH07XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCB0ZXh0ID0gYXdhaXQgcmVxLnRleHQoKTtcblxuICAgICAgICB0cnkge1xuICAgICAgICAgIHNvdXJjZSA9IHRleHQ7XG4gICAgICAgICAgZG9jdW1lbnQgPSB5YW1sLnNhZmVMb2FkKHRleHQpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgY3R4LnJlc3VsdC5wdXNoKGNyZWF0ZVlBTUxQYXJzZUVycm9yKGUsIGN0eCwgcmVzb2x2ZWRGaWxlUGF0aCwgc291cmNlKSk7XG4gICAgICAgICAgcmV0dXJuIHsgbm9kZTogdW5kZWZpbmVkIH07XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgLy8gRklYTUU6IGxvc3QgeWFtbCBwYXJzaW5nIGVycm9ycyBhbmQgbmV0d29yayBlcnJvcnMgaGVyZVxuICAgICAgICByZXR1cm4geyBub2RlOiB1bmRlZmluZWQgfTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHsgbm9kZTogdW5kZWZpbmVkIH07XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGRvY3VtZW50ID0gY3R4LmRvY3VtZW50O1xuICAgIHNvdXJjZSA9IGN0eC5zb3VyY2U7XG4gIH1cblxuICBpZiAoc291cmNlKSBjdHgucmVzb2x2ZUNhY2hlW3Jlc29sdmVkRmlsZVBhdGhdID0geyBzb3VyY2UsIGRvY3VtZW50IH07XG5cbiAgY3R4LnNvdXJjZSA9IHNvdXJjZTtcbiAgY3R4LmRvY3VtZW50ID0gZG9jdW1lbnQ7XG5cbiAgY29uc3QgZG9jUGF0aFN0ZXBzID0gZG9jUGF0aCA/IGRvY1BhdGguc3BsaXQoJy8nKS5maWx0ZXIoKGVsKSA9PiBlbCAhPT0gJycpLnJldmVyc2UoKSA6IFtdO1xuXG4gIGxldCB0YXJnZXQgPSBkb2N1bWVudDtcbiAgbGV0IGNpcmN1bGFyO1xuICBsZXQgdHJhbnNpdGl2ZVJlc29sdmVzT25TdGFjayA9IDA7XG4gIGxldCB0cmFuc2l0aXZlRXJyb3I7XG5cbiAgaWYgKHZpc2l0ZWQuaW5kZXhPZihyZXNvbHZlZExpbmspID4gLTEpIHtcbiAgICB0YXJnZXQgPSB1bmRlZmluZWQ7XG4gICAgY2lyY3VsYXIgPSB0cnVlO1xuICB9XG5cbiAgdmlzaXRlZC5wdXNoKHJlc29sdmVkTGluayk7XG5cbiAgd2hpbGUgKHRhcmdldCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgaWYgKHRhcmdldCAmJiB0YXJnZXQuJHJlZikge1xuICAgICAgLy8gaGFuZGxlIHRyYW5zaXRpdmUgJHJlZidzXG4gICAgICBjb25zdCByZXNvbHZlZCA9IGF3YWl0IHJlc29sdmUodGFyZ2V0LiRyZWYsIGN0eCwgdmlzaXRlZCk7XG4gICAgICB0cmFuc2l0aXZlRXJyb3IgPSByZXNvbHZlZC50cmFuc2l0aXZlRXJyb3I7XG4gICAgICBpZiAocmVzb2x2ZWQubm9kZSA9PT0gdW5kZWZpbmVkICYmICF0cmFuc2l0aXZlRXJyb3IpIHtcbiAgICAgICAgLy8gV2Ugd2FudCB0byBzaG93IG9ubHkgdGhlIGVycm9yIGZvciB0aGUgZmlyc3QgJHJlZiB0aGF0IGNhbid0IGJlIHJlc29sdmVkLlxuICAgICAgICAvLyBTbyB3ZSBjcmVhdGUgaXQgb24gdGhlIGN1cnJlbnQgc3RhY2sgYW5kIHByb3BhZ2F0ZSBpdCBvdXQgYXMgYSB0cmFuc2l0aXZlRXJyb3JcbiAgICAgICAgcG9wUGF0aChjdHgpO1xuICAgICAgICBjdHgucGF0aC5wdXNoKCckcmVmJyk7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSByZXNvbHZlZC5jaXJjdWxhciA/ICdDaXJjdWxhciByZWZlcmVuY2UuJyA6ICdSZWZlcmVuY2UgZG9lcyBub3QgZXhpc3QuJztcbiAgICAgICAgdHJhbnNpdGl2ZUVycm9yID0gY3JlYXRlRXJyb3IobWVzc2FnZSwgdGFyZ2V0LCBjdHgsIHsgZnJvbVJ1bGU6ICdyZXNvbHZlLXJlZicgfSk7XG4gICAgICAgIGN0eC5wYXRoLnBvcCgpO1xuICAgICAgICB0YXJnZXQgPSB1bmRlZmluZWQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgdGFyZ2V0ID0gcmVzb2x2ZWQubm9kZTtcbiAgICAgIHRyYW5zaXRpdmVSZXNvbHZlc09uU3RhY2srKztcbiAgICB9XG5cbiAgICBsZXQgc3RlcCA9IGRvY1BhdGhTdGVwcy5wb3AoKTtcbiAgICBpZiAoIXN0ZXApIGJyZWFrO1xuICAgIHN0ZXAgPSBkZWNvZGVQb2ludGVyQ29tcG9uZW50KHN0ZXApO1xuXG4gICAgdGFyZ2V0ID0gdGFyZ2V0ICYmIHRhcmdldFtzdGVwXSAhPT0gdW5kZWZpbmVkID8gdGFyZ2V0W3N0ZXBdIDogdW5kZWZpbmVkO1xuICAgIGN0eC5wYXRoLnB1c2goc3RlcCk7XG4gIH1cblxuICBmb3IgKGxldCBpID0gMDsgaSA8IHRyYW5zaXRpdmVSZXNvbHZlc09uU3RhY2s7ICsraSkge1xuICAgIC8vIGtlZXAgY3VycmVudCBmaWxlIGNvbnRleHQgYW5kIHJlbW92ZSBpbmRpcmVjdGlvbiByZWNvcmRzXG4gICAgY3R4LnBhdGhTdGFjay5wb3AoKTtcbiAgfVxuXG4gIGlmICh0cmFuc2l0aXZlRXJyb3IpIHtcbiAgICAvLyByZWNhbGMgcmVmZXJlbmNlZEZyb20gYWZ0ZXIgZXhpdGluZyB0cmFuc2l0aXZlIHJlZiBzdGFjayB0byBzaG93IG9yaWdpbmFsICRyZWYgaW4gdGhlIGVycm9yXG4gICAgdHJhbnNpdGl2ZUVycm9yLnJlZmVyZW5jZWRGcm9tID0gZ2V0UmVmZXJlbmNlZEZyb20oY3R4KTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgbm9kZTogdGFyZ2V0LFxuICAgIHRyYW5zaXRpdmVFcnJvcixcbiAgICBjaXJjdWxhcixcbiAgfTtcbn1cblxuXG4vKlxuICogVGhpcyBmdW5jdGlvbiBpcyB1c2VkIHRvIHJlc29sdmUgJHJlZiBmaWVsZHMgaW5zaWRlIHRoZSBub2RlLiBDdXJyZW50bHkgc3VwcG9ydHMgbGlua3M6XG4gKiAtIGluc2lkZSB0aGUgZmlsZVxuICogLSB0byB0aGUgYW5vdGhlciBmaWxlIGluIGxvY2FsIGZpbGUgc3lzdGVtXG4gKiAtIGh0dHAocykgbGlua3MgdG8gb3RoZXIgZmlsZXNcbiAqXG4gKiAkcmVmIGZpZWxkIHZhbHVlIG11c3QgYmUgYSB2YWxpZCBPcGVuQVBJIGxpbmtcbiAqIChlLmcuIGFub3RoZXIvZGlyL2ZpbGUueWFtbCMvY29tcG9uZW50cy9zY2hlbWFzL0V4YW1wbGUpXG4gKlxuICogQHBhcmFtIHsqfSBub2RlXG4gKiBAcGFyYW0geyp9IGN0eFxuICovXG5hc3luYyBmdW5jdGlvbiByZXNvbHZlTm9kZShub2RlLCBjdHgpIHtcbiAgaWYgKCFub2RlIHx8IHR5cGVvZiBub2RlICE9PSAnb2JqZWN0JykgcmV0dXJuIHsgbm9kZSB9O1xuXG4gIGlmIChub2RlLiRyZWYpIHtcbiAgICBjb25zdCByZXNvbHZlZCA9IGF3YWl0IHJlc29sdmUobm9kZS4kcmVmLCBjdHgpO1xuICAgIGlmIChyZXNvbHZlZC5ub2RlID09PSB1bmRlZmluZWQpIHsgLy8gY2FuJ3QgcmVzb2x2ZVxuICAgICAgcG9wUGF0aChjdHgpO1xuXG4gICAgICBjdHgucGF0aC5wdXNoKCckcmVmJyk7XG4gICAgICBjb25zdCBlcnJvciA9IHJlc29sdmVkLnRyYW5zaXRpdmVFcnJvclxuICAgICAgICA/IHJlc29sdmVkLnRyYW5zaXRpdmVFcnJvclxuICAgICAgICA6IGNyZWF0ZUVycm9yKCdSZWZlcmVuY2UgZG9lcyBub3QgZXhpc3QuJywgbm9kZSwgY3R4LCB7IGZyb21SdWxlOiAncmVzb2x2ZS1yZWYnIH0pO1xuICAgICAgY3R4LnBhdGgucG9wKCk7XG5cbiAgICAgIGN0eC5yZXN1bHQucHVzaChlcnJvcik7XG5cbiAgICAgIHJldHVybiB7IG5vZGUgfTtcbiAgICB9XG5cbiAgICByZXR1cm4geyBub2RlOiByZXNvbHZlZC5ub2RlLCBvblN0YWNrOiB0cnVlIH07XG4gIH1cblxuICByZXR1cm4geyBub2RlIH07XG59XG5cbi8vIHRvIGJlIHVzZWQgaW4gbXV0YXRvcnNcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiByZXNvbHZlTm9kZU5vU2lkZUVmZmVjdHMobm9kZSwgY3R4KSB7XG4gIGNvbnN0IGN0eENvcHkgPSB7IC4uLmN0eCwgcGF0aFN0YWNrOiBjdHgucGF0aFN0YWNrLnNsaWNlKCkgfTtcbiAgcmV0dXJuIHJlc29sdmVOb2RlKG5vZGUsIGN0eENvcHkpO1xufVxuXG5leHBvcnQgZGVmYXVsdCByZXNvbHZlTm9kZTtcbiJdfQ==