#!/usr/bin/env node
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _chalk = _interopRequireDefault(require("chalk"));

var _commander = _interopRequireDefault(require("commander"));

var _fs = _interopRequireDefault(require("fs"));

var _path = require("path");

var chockidar = _interopRequireWildcard(require("chokidar"));

var _redocly = _interopRequireDefault(require("../redocly"));

var _utils = require("./utils");

var _validate = require("../validate");

var _bundle = require("../bundle");

var _utils2 = require("../utils");

var _outputMessages = require("./outputMessages");

var _config = require("../config");

var _previewDocs = _interopRequireDefault(require("../preview-docs"));

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const program = new _commander.default.Command();

const validateFile = async (filePath, options, cmdObj) => {
  let result;

  if (!_fs.default.existsSync(filePath) && (0, _utils2.isFullyQualifiedUrl)(filePath)) {
    process.stdout.write('Will validate from URL\n');
    result = await (0, _validate.validateFromUrl)(filePath, options);
  } else {
    result = await (0, _validate.validateFromFile)(filePath, options);
  }

  const resultStats = (0, _outputMessages.outputMessages)(result, cmdObj);
  const {
    totalErrors,
    totalWarnings
  } = resultStats;
  process.stdout.write(`${_chalk.default.blueBright(filePath)} results. Errors: ${totalErrors}, warnings: ${totalWarnings}\n`);
  return {
    errors: resultStats.totalErrors,
    warnings: resultStats.totalWarnings
  };
};

const cli = () => {
  const f = _fs.default.readFileSync(`${__dirname}/../package.json`, 'utf-8');

  const {
    version
  } = JSON.parse(f);
  program.version(version, '-v, --version', 'Output current version of the OpenAPI CLI.');
  program.command('registry:login').description('Login to the Redoc.ly API Registry with access token').option('-p, --prompt', 'Ask for credentials instead of looking them in the .env or enviroment variables').action(async () => {
    const clientToken = await (0, _utils.promptUser)(_chalk.default.green(`\n  ðŸ”‘ Copy your access token from ${_chalk.default.blue(`https://app.${process.env.REDOCLY_DOMAIN || 'redoc.ly'}/profile`)} and paste it below`));
    const client = new _redocly.default();
    client.login(clientToken);
  });
  program.command('registry:logout').description('Clear stored credentials for Redoc.ly API Registry').action(async () => {
    const client = new _redocly.default();
    client.logout();
  });
  program.command('bundle [entryPoints...]').description('Create a bundle using <entryPoint> as a root document.').option('-o, --output <outputName>', 'Filename or folder for the bundle.').option('--short', 'Reduce output in case of bundling errors.').option('--ext <ext>', 'Output extension: json, yaml or yml').option('-f, --force', 'Produce bundle output file even if validation errors were encountered').action(async (entryPoints, cmdObj) => {
    if (cmdObj.ext && ['yaml', 'yml', 'json'].indexOf(cmdObj.ext) === -1) {
      process.stdout.write('Unsupported value for --ext option. Supported values are: yaml, yml or json');
      process.exit(1);
    }

    const config = (0, _config.getConfig)({}); // eslint-disable-next-line no-param-reassign

    entryPoints = (0, _config.getFallbackEntryPointsOrExit)(entryPoints, config);
    const isOutputDir = cmdObj.output && !(0, _path.extname)(cmdObj.output);
    const ext = cmdObj.ext || (0, _path.extname)(cmdObj.output || '').substring(1) || 'yaml';
    const dir = isOutputDir ? cmdObj.output : (0, _path.dirname)(cmdObj.output || '');
    const results = {
      errors: 0,
      warnings: 0
    };

    for (const entryPoint of entryPoints) {
      let output;

      if (cmdObj.output) {
        const fileName = isOutputDir ? (0, _path.basename)(entryPoint, (0, _path.extname)(entryPoint)) : (0, _path.basename)(cmdObj.output, `.${ext}`);
        output = (0, _path.join)(dir, `${fileName}.${ext}`);
      }

      const bundlingStatus = await (0, _bundle.bundleToFile)(entryPoint, output, cmdObj.force);
      const resultStats = (0, _outputMessages.outputMessages)(bundlingStatus, cmdObj);

      if (resultStats.totalErrors === 0) {
        // we do not want to output anything to stdout if it's being piped.
        if (output) {
          process.stdout.write(`Created a bundle for ${entryPoint} at ${output}\n`);
        }
      } else {
        if (cmdObj.force) {
          process.stderr.write(`Created a bundle for ${entryPoint} at ${output}. Errors ignored because of --force\n`);
        } else {
          process.stderr.write(`Errors encountered while bundling ${entryPoint}: bundle not created (use --force to ignore errors)\n`);
        }

        results.errors += resultStats.totalErrors;
        results.warnings += resultStats.totalWarnings;
      }
    }

    process.exit(results.errors === 0 || cmdObj.force ? 0 : 1);
  });
  program.command('validate [entryPoints...]').description('Validate given OpenAPI 3 definition file.').option('--short', 'Reduce output to required minimun.').option('--no-frame', 'Print no codeframes with errors.').option('--config <path>', 'Specify custom yaml or json config').action(async (entryPoints, cmdObj) => {
    const options = {};
    const results = {
      errors: 0,
      warnings: 0
    };
    const config = (0, _config.getConfig)({}); // eslint-disable-next-line no-param-reassign

    entryPoints = (0, _config.getFallbackEntryPointsOrExit)(entryPoints, config);
    options.codeframes = cmdObj.frame;
    if (cmdObj.config) options.configPath = cmdObj.config;

    for (let i = 0; i < entryPoints.length; i++) {
      (0, _outputMessages.printValidationHeader)(entryPoints[i]);
      const msgs = await validateFile(entryPoints[i], options, cmdObj);
      results.errors += msgs.errors;
      results.warnings += msgs.warnings;
    }

    if (entryPoints.length > 1) {
      process.stdout.write(`Validation results:\nerrors: ${results.errors}\nwarnings: ${results.warnings}\n`);
    }

    process.exit(results.errors > 0 ? 1 : 0);
  });

  function myParseInt(value) {
    return parseInt(value, 10);
  }

  program.command('preview-docs [entryPoint]').description('Preview API Reference docs for the specified entrypoint OAS definition').option('-p, --port <value>', 'Preview port', myParseInt, 8080).option('--use-community-edition', 'Use Redoc CE for docs preview.').action(async (entryPoint, cmdObj) => {
    const output = 'dist/openapi.yaml';
    let config = (0, _config.getConfig)({}); // eslint-disable-next-line no-param-reassign, prefer-destructuring

    entryPoint = (0, _config.getFallbackEntryPointsOrExit)(entryPoint ? [entryPoint] : [], config)[0];
    let cachedBundle;
    const deps = new Set();

    async function getBundle() {
      return cachedBundle;
    }

    async function updateBundle() {
      process.stdout.write('\nBundling...\n\n');
      const {
        bundle: openapiBundle,
        result,
        fileDependencies
      } = await (0, _bundle.bundle)(entryPoint, output, {
        lint: {
          codeframes: false
        }
      });
      const removed = [...deps].filter(x => !fileDependencies.has(x));
      watcher.unwatch(removed);
      watcher.add([...fileDependencies]);
      deps.clear();
      fileDependencies.forEach(deps.add, deps);
      const resultStats = (0, _outputMessages.outputMessages)(result, {
        short: true
      });

      if (resultStats.totalErrors === 0) {
        process.stdout.write(resultStats.totalErrors === 0 ? `Created a bundle for ${entryPoint} ${resultStats.totalWarnings > 0 ? 'with warnings' : 'successfully'}\n` : _chalk.default.yellow(`Created a bundle for ${entryPoint} with errors. Docs may be broken or not accurate\n`));
      }

      return openapiBundle;
    }

    const redoclyClient = new _redocly.default();
    const isAuthorizedWithRedocly = await redoclyClient.isAuthorizedWithRedocly();
    setImmediate(() => {
      cachedBundle = updateBundle();
    }); // initial cache

    const referenceDocs = config.referenceDocs || {};
    const redocOptions = { ...referenceDocs,
      useCommunityEdition: cmdObj.useCommunityEdition || referenceDocs.useCommunityEdition,
      licenseKey: process.env.REDOCLY_LICENSE_KEY || referenceDocs.licenseKey
    };
    const hotClients = await (0, _previewDocs.default)(cmdObj.port, {
      getBundle,
      getOptions: () => redocOptions,
      useRedocPro: (isAuthorizedWithRedocly || redocOptions.licenseKey) && !redocOptions.useCommunityEdition
    });
    const watcher = chockidar.watch([entryPoint, config.configPath], {
      disableGlobbing: true,
      ignoreInitial: true
    });
    const debouncedUpdatedeBundle = (0, _utils2.debounce)(async () => {
      cachedBundle = updateBundle();
      await cachedBundle;
      hotClients.broadcast('{"type": "reload", "bundle": true}');
    }, 2000);

    const changeHandler = async (type, file) => {
      process.stdout.write(`${_chalk.default.green('watch')} ${type} ${_chalk.default.blue(file)}\n`);

      if (file === config.configPath) {
        config = (0, _config.getConfig)({
          configPath: file
        });
        hotClients.broadcast(JSON.stringify({
          type: 'reload'
        }));
        return;
      }

      debouncedUpdatedeBundle();
    };

    watcher.on('change', changeHandler.bind(undefined, 'changed'));
    watcher.on('add', changeHandler.bind(undefined, 'added'));
    watcher.on('unlink', changeHandler.bind(undefined, 'removed'));
    watcher.on('ready', () => {
      process.stdout.write(`\n  ðŸ‘€  Watching ${_chalk.default.blue(entryPoint)} and all related resources for changes\n`);
    });
  });
  program.on('command:*', () => {
    process.stderr.write(`\nUnknown command ${program.args.join(' ')}\n\n`);
    program.outputHelp();
  });
  if (process.argv.length === 2) process.argv.push('-h');
  program.parse(process.argv);
};

var _default = cli;
exports.default = _default;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9jbGkvaW5kZXguanMiXSwibmFtZXMiOlsicHJvZ3JhbSIsImNvbW1hbmRlciIsIkNvbW1hbmQiLCJ2YWxpZGF0ZUZpbGUiLCJmaWxlUGF0aCIsIm9wdGlvbnMiLCJjbWRPYmoiLCJyZXN1bHQiLCJmcyIsImV4aXN0c1N5bmMiLCJwcm9jZXNzIiwic3Rkb3V0Iiwid3JpdGUiLCJyZXN1bHRTdGF0cyIsInRvdGFsRXJyb3JzIiwidG90YWxXYXJuaW5ncyIsImNoYWxrIiwiYmx1ZUJyaWdodCIsImVycm9ycyIsIndhcm5pbmdzIiwiY2xpIiwiZiIsInJlYWRGaWxlU3luYyIsIl9fZGlybmFtZSIsInZlcnNpb24iLCJKU09OIiwicGFyc2UiLCJjb21tYW5kIiwiZGVzY3JpcHRpb24iLCJvcHRpb24iLCJhY3Rpb24iLCJjbGllbnRUb2tlbiIsImdyZWVuIiwiYmx1ZSIsImVudiIsIlJFRE9DTFlfRE9NQUlOIiwiY2xpZW50IiwiUmVkb2NseUNsaWVudCIsImxvZ2luIiwibG9nb3V0IiwiZW50cnlQb2ludHMiLCJleHQiLCJpbmRleE9mIiwiZXhpdCIsImNvbmZpZyIsImlzT3V0cHV0RGlyIiwib3V0cHV0Iiwic3Vic3RyaW5nIiwiZGlyIiwicmVzdWx0cyIsImVudHJ5UG9pbnQiLCJmaWxlTmFtZSIsImJ1bmRsaW5nU3RhdHVzIiwiZm9yY2UiLCJzdGRlcnIiLCJjb2RlZnJhbWVzIiwiZnJhbWUiLCJjb25maWdQYXRoIiwiaSIsImxlbmd0aCIsIm1zZ3MiLCJteVBhcnNlSW50IiwidmFsdWUiLCJwYXJzZUludCIsImNhY2hlZEJ1bmRsZSIsImRlcHMiLCJTZXQiLCJnZXRCdW5kbGUiLCJ1cGRhdGVCdW5kbGUiLCJidW5kbGUiLCJvcGVuYXBpQnVuZGxlIiwiZmlsZURlcGVuZGVuY2llcyIsImxpbnQiLCJyZW1vdmVkIiwiZmlsdGVyIiwieCIsImhhcyIsIndhdGNoZXIiLCJ1bndhdGNoIiwiYWRkIiwiY2xlYXIiLCJmb3JFYWNoIiwic2hvcnQiLCJ5ZWxsb3ciLCJyZWRvY2x5Q2xpZW50IiwiaXNBdXRob3JpemVkV2l0aFJlZG9jbHkiLCJzZXRJbW1lZGlhdGUiLCJyZWZlcmVuY2VEb2NzIiwicmVkb2NPcHRpb25zIiwidXNlQ29tbXVuaXR5RWRpdGlvbiIsImxpY2Vuc2VLZXkiLCJSRURPQ0xZX0xJQ0VOU0VfS0VZIiwiaG90Q2xpZW50cyIsInBvcnQiLCJnZXRPcHRpb25zIiwidXNlUmVkb2NQcm8iLCJjaG9ja2lkYXIiLCJ3YXRjaCIsImRpc2FibGVHbG9iYmluZyIsImlnbm9yZUluaXRpYWwiLCJkZWJvdW5jZWRVcGRhdGVkZUJ1bmRsZSIsImJyb2FkY2FzdCIsImNoYW5nZUhhbmRsZXIiLCJ0eXBlIiwiZmlsZSIsInN0cmluZ2lmeSIsIm9uIiwiYmluZCIsInVuZGVmaW5lZCIsImFyZ3MiLCJqb2luIiwib3V0cHV0SGVscCIsImFyZ3YiLCJwdXNoIl0sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7Ozs7QUFFQTs7QUFDQTs7QUFFQTs7QUFDQTs7QUFHQTs7QUFFQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFFQTs7QUFFQTs7QUFDQTs7QUFFQTs7Ozs7Ozs7QUFFQSxNQUFNQSxPQUFPLEdBQUcsSUFBSUMsbUJBQVVDLE9BQWQsRUFBaEI7O0FBRUEsTUFBTUMsWUFBWSxHQUFHLE9BQU9DLFFBQVAsRUFBaUJDLE9BQWpCLEVBQTBCQyxNQUExQixLQUFxQztBQUN4RCxNQUFJQyxNQUFKOztBQUVBLE1BQUksQ0FBQ0MsWUFBR0MsVUFBSCxDQUFjTCxRQUFkLENBQUQsSUFBNEIsaUNBQW9CQSxRQUFwQixDQUFoQyxFQUErRDtBQUM3RE0sSUFBQUEsT0FBTyxDQUFDQyxNQUFSLENBQWVDLEtBQWYsQ0FBcUIsMEJBQXJCO0FBQ0FMLElBQUFBLE1BQU0sR0FBRyxNQUFNLCtCQUFnQkgsUUFBaEIsRUFBMEJDLE9BQTFCLENBQWY7QUFDRCxHQUhELE1BR087QUFDTEUsSUFBQUEsTUFBTSxHQUFHLE1BQU0sZ0NBQWlCSCxRQUFqQixFQUEyQkMsT0FBM0IsQ0FBZjtB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cnQgY29tbWFuZGVyIGZyb20gJ2NvbW1hbmRlcic7XG5cbmltcG9ydCBmcyBmcm9tICdmcyc7XG5pbXBvcnQge1xuICBqb2luLCBiYXNlbmFtZSwgZGlybmFtZSwgZXh0bmFtZSxcbn0gZnJvbSAncGF0aCc7XG5pbXBvcnQgKiBhcyBjaG9ja2lkYXIgZnJvbSAnY2hva2lkYXInO1xuXG5pbXBvcnQgUmVkb2NseUNsaWVudCBmcm9tICcuLi9yZWRvY2x5JztcbmltcG9ydCB7IHByb21wdFVzZXIgfSBmcm9tICcuL3V0aWxzJztcbmltcG9ydCB7IHZhbGlkYXRlRnJvbUZpbGUsIHZhbGlkYXRlRnJvbVVybCB9IGZyb20gJy4uL3ZhbGlkYXRlJztcbmltcG9ydCB7IGJ1bmRsZSwgYnVuZGxlVG9GaWxlIH0gZnJvbSAnLi4vYnVuZGxlJztcblxuaW1wb3J0IHsgaXNGdWxseVF1YWxpZmllZFVybCwgZGVib3VuY2UgfSBmcm9tICcuLi91dGlscyc7XG5cbmltcG9ydCB7IG91dHB1dE1lc3NhZ2VzLCBwcmludFZhbGlkYXRpb25IZWFkZXIgfSBmcm9tICcuL291dHB1dE1lc3NhZ2VzJztcbmltcG9ydCB7IGdldEZhbGxiYWNrRW50cnlQb2ludHNPckV4aXQsIGdldENvbmZpZyB9IGZyb20gJy4uL2NvbmZpZyc7XG5cbmltcG9ydCBzdGFydFByZXZpZXdTZXJ2ZXIgZnJvbSAnLi4vcHJldmlldy1kb2NzJztcblxuY29uc3QgcHJvZ3JhbSA9IG5ldyBjb21tYW5kZXIuQ29tbWFuZCgpO1xuXG5jb25zdCB2YWxpZGF0ZUZpbGUgPSBhc3luYyAoZmlsZVBhdGgsIG9wdGlvbnMsIGNtZE9iaikgPT4ge1xuICBsZXQgcmVzdWx0O1xuXG4gIGlmICghZnMuZXhpc3RzU3luYyhmaWxlUGF0aCkgJiYgaXNGdWxseVF1YWxpZmllZFVybChmaWxlUGF0aCkpIHtcbiAgICBwcm9jZXNzLnN0ZG91dC53cml0ZSgnV2lsbCB2YWxpZGF0ZSBmcm9tIFVSTFxcbicpO1xuICAgIHJlc3VsdCA9IGF3YWl0IHZhbGlkYXRlRnJvbVVybChmaWxlUGF0aCwgb3B0aW9ucyk7XG4gIH0gZWxzZSB7XG4gICAgcmVzdWx0ID0gYXdhaXQgdmFsaWRhdGVGcm9tRmlsZShmaWxlUGF0aCwgb3B0aW9ucyk7XG4gIH1cbiAgY29uc3QgcmVzdWx0U3RhdHMgPSBvdXRwdXRNZXNzYWdlcyhyZXN1bHQsIGNtZE9iaik7XG5cbiAgY29uc3QgeyB0b3RhbEVycm9ycywgdG90YWxXYXJuaW5ncyB9ID0gcmVzdWx0U3RhdHM7XG4gIHByb2Nlc3Muc3Rkb3V0LndyaXRlKFxuICAgIGAke2NoYWxrLmJsdWVCcmlnaHQoZmlsZVBhdGgpfSByZXN1bHRzLiBFcnJvcnM6ICR7dG90YWxFcnJvcnN9LCB3YXJuaW5nczogJHt0b3RhbFdhcm5pbmdzfVxcbmAsXG4gICk7XG5cbiAgcmV0dXJuIHtcbiAgICBlcnJvcnM6IHJlc3VsdFN0YXRzLnRvdGFsRXJyb3JzLFxuICAgIHdhcm5pbmdzOiByZXN1bHRTdGF0cy50b3RhbFdhcm5pbmdzLFxuICB9O1xufTtcblxuY29uc3QgY2xpID0gKCkgPT4ge1xuICBjb25zdCBmID0gZnMucmVhZEZpbGVTeW5jKGAke19fZGlybmFtZX0vLi4vcGFja2FnZS5qc29uYCwgJ3V0Zi04Jyk7XG4gIGNvbnN0IHsgdmVyc2lvbiB9ID0gSlNPTi5wYXJzZShmKTtcblxuICBwcm9ncmFtXG4gICAgLnZlcnNpb24odmVyc2lvbiwgJy12LCAtLXZlcnNpb24nLCAnT3V0cHV0IGN1cnJlbnQgdmVyc2lvbiBvZiB0aGUgT3BlbkFQSSBDTEkuJyk7XG5cbiAgcHJvZ3JhbVxuICAgIC5jb21tYW5kKCdyZWdpc3RyeTpsb2dpbicpXG4gICAgLmRlc2NyaXB0aW9uKCdMb2dpbiB0byB0aGUgUmVkb2MubHkgQVBJIFJlZ2lzdHJ5IHdpdGggYWNjZXNzIHRva2VuJylcbiAgICAub3B0aW9uKCctcCwgLS1wcm9tcHQnLCAnQXNrIGZvciBjcmVkZW50aWFscyBpbnN0ZWFkIG9mIGxvb2tpbmcgdGhlbSBpbiB0aGUgLmVudiBvciBlbnZpcm9tZW50IHZhcmlhYmxlcycpXG4gICAgLmFjdGlvbihhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBjbGllbnRUb2tlbiA9IGF3YWl0IHByb21wdFVzZXIoXG4gICAgICAgIGNoYWxrLmdyZWVuKGBcXG4gIPCflJEgQ29weSB5b3VyIGFjY2VzcyB0b2tlbiBmcm9tICR7Y2hhbGsuYmx1ZShgaHR0cHM6Ly9hcHAuJHtwcm9jZXNzLmVudi5SRURPQ0xZX0RPTUFJTiB8fCAncmVkb2MubHknfS9wcm9maWxlYCl9IGFuZCBwYXN0ZSBpdCBiZWxvd2ApLFxuICAgICAgKTtcbiAgICAgIGNvbnN0IGNsaWVudCA9IG5ldyBSZWRvY2x5Q2xpZW50KCk7XG4gICAgICBjbGllbnQubG9naW4oY2xpZW50VG9rZW4pO1xuICAgIH0pO1xuXG4gIHByb2dyYW1cbiAgICAuY29tbWFuZCgncmVnaXN0cnk6bG9nb3V0JylcbiAgICAuZGVzY3JpcHRpb24oJ0NsZWFyIHN0b3JlZCBjcmVkZW50aWFscyBmb3IgUmVkb2MubHkgQVBJIFJlZ2lzdHJ5JylcbiAgICAuYWN0aW9uKGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IGNsaWVudCA9IG5ldyBSZWRvY2x5Q2xpZW50KCk7XG4gICAgICBjbGllbnQubG9nb3V0KCk7XG4gICAgfSk7XG5cbiAgcHJvZ3JhbVxuICAgIC5jb21tYW5kKCdidW5kbGUgW2VudHJ5UG9pbnRzLi4uXScpXG4gICAgLmRlc2NyaXB0aW9uKCdDcmVhdGUgYSBidW5kbGUgdXNpbmcgPGVudHJ5UG9pbnQ+IGFzIGEgcm9vdCBkb2N1bWVudC4nKVxuICAgIC5vcHRpb24oJy1vLCAtLW91dHB1dCA8b3V0cHV0TmFtZT4nLCAnRmlsZW5hbWUgb3IgZm9sZGVyIGZvciB0aGUgYnVuZGxlLicpXG4gICAgLm9wdGlvbignLS1zaG9ydCcsICdSZWR1Y2Ugb3V0cHV0IGluIGNhc2Ugb2YgYnVuZGxpbmcgZXJyb3JzLicpXG4gICAgLm9wdGlvbignLS1leHQgPGV4dD4nLCAnT3V0cHV0IGV4dGVuc2lvbjoganNvbiwgeWFtbCBvciB5bWwnKVxuICAgIC5vcHRpb24oJy1mLCAtLWZvcmNlJywgJ1Byb2R1Y2UgYnVuZGxlIG91dHB1dCBmaWxlIGV2ZW4gaWYgdmFsaWRhdGlvbiBlcnJvcnMgd2VyZSBlbmNvdW50ZXJlZCcpXG4gICAgLmFjdGlvbihhc3luYyAoZW50cnlQb2ludHMsIGNtZE9iaikgPT4ge1xuICAgICAgaWYgKGNtZE9iai5leHQgJiYgWyd5YW1sJywgJ3ltbCcsICdqc29uJ10uaW5kZXhPZihjbWRPYmouZXh0KSA9PT0gLTEpIHtcbiAgICAgICAgcHJvY2Vzcy5zdGRvdXQud3JpdGUoXG4gICAgICAgICAgJ1Vuc3VwcG9ydGVkIHZhbHVlIGZvciAtLWV4dCBvcHRpb24uIFN1cHBvcnRlZCB2YWx1ZXMgYXJlOiB5YW1sLCB5bWwgb3IganNvbicsXG4gICAgICAgICk7XG4gICAgICAgIHByb2Nlc3MuZXhpdCgxKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgY29uZmlnID0gZ2V0Q29uZmlnKHt9KTtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuICAgICAgZW50cnlQb2ludHMgPSBnZXRGYWxsYmFja0VudHJ5UG9pbnRzT3JFeGl0KGVudHJ5UG9pbnRzLCBjb25maWcpO1xuXG4gICAgICBjb25zdCBpc091dHB1dERpciA9IGNtZE9iai5vdXRwdXQgJiYgIWV4dG5hbWUoY21kT2JqLm91dHB1dCk7XG4gICAgICBjb25zdCBleHQgPSBjbWRPYmouZXh0IHx8IGV4dG5hbWUoY21kT2JqLm91dHB1dCB8fCAnJykuc3Vic3RyaW5nKDEpIHx8ICd5YW1sJztcbiAgICAgIGNvbnN0IGRpciA9IGlzT3V0cHV0RGlyID8gY21kT2JqLm91dHB1dCA6IGRpcm5hbWUoY21kT2JqLm91dHB1dCB8fCAnJyk7XG5cbiAgICAgIGNvbnN0IHJlc3VsdHMgPSB7XG4gICAgICAgIGVycm9yczogMCxcbiAgICAgICAgd2FybmluZ3M6IDAsXG4gICAgICB9O1xuXG4gICAgICBmb3IgKGNvbnN0IGVudHJ5UG9pbnQgb2YgZW50cnlQb2ludHMpIHtcbiAgICAgICAgbGV0IG91dHB1dDtcbiAgICAgICAgaWYgKGNtZE9iai5vdXRwdXQpIHtcbiAgICAgICAgICBjb25zdCBmaWxlTmFtZSA9IGlzT3V0cHV0RGlyXG4gICAgICAgICAgICA/IGJhc2VuYW1lKGVudHJ5UG9pbnQsIGV4dG5hbWUoZW50cnlQb2ludCkpXG4gICAgICAgICAgICA6IGJhc2VuYW1lKGNtZE9iai5vdXRwdXQsIGAuJHtleHR9YCk7XG4gICAgICAgICAgb3V0cHV0ID0gam9pbihkaXIsIGAke2ZpbGVOYW1lfS4ke2V4dH1gKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGJ1bmRsaW5nU3RhdHVzID0gYXdhaXQgYnVuZGxlVG9GaWxlKGVudHJ5UG9pbnQsIG91dHB1dCwgY21kT2JqLmZvcmNlKTtcbiAgICAgICAgY29uc3QgcmVzdWx0U3RhdHMgPSBvdXRwdXRNZXNzYWdlcyhidW5kbGluZ1N0YXR1cywgY21kT2JqKTtcblxuICAgICAgICBpZiAocmVzdWx0U3RhdHMudG90YWxFcnJvcnMgPT09IDApIHtcbiAgICAgICAgICAvLyB3ZSBkbyBub3Qgd2FudCB0byBvdXRwdXQgYW55dGhpbmcgdG8gc3Rkb3V0IGlmIGl0J3MgYmVpbmcgcGlwZWQuXG4gICAgICAgICAgaWYgKG91dHB1dCkge1xuICAgICAgICAgICAgcHJvY2Vzcy5zdGRvdXQud3JpdGUoYENyZWF0ZWQgYSBidW5kbGUgZm9yICR7ZW50cnlQb2ludH0gYXQgJHtvdXRwdXR9XFxuYCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChjbWRPYmouZm9yY2UpIHtcbiAgICAgICAgICAgIHByb2Nlc3Muc3RkZXJyLndyaXRlKFxuICAgICAgICAgICAgICBgQ3JlYXRlZCBhIGJ1bmRsZSBmb3IgJHtlbnRyeVBvaW50fSBhdCAke291dHB1dH0uIEVycm9ycyBpZ25vcmVkIGJlY2F1c2Ugb2YgLS1mb3JjZVxcbmAsXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwcm9jZXNzLnN0ZGVyci53cml0ZShcbiAgICAgICAgICAgICAgYEVycm9ycyBlbmNvdW50ZXJlZCB3aGlsZSBidW5kbGluZyAke2VudHJ5UG9pbnR9OiBidW5kbGUgbm90IGNyZWF0ZWQgKHVzZSAtLWZvcmNlIHRvIGlnbm9yZSBlcnJvcnMpXFxuYCxcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJlc3VsdHMuZXJyb3JzICs9IHJlc3VsdFN0YXRzLnRvdGFsRXJyb3JzO1xuICAgICAgICAgIHJlc3VsdHMud2FybmluZ3MgKz0gcmVzdWx0U3RhdHMudG90YWxXYXJuaW5ncztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcHJvY2Vzcy5leGl0KHJlc3VsdHMuZXJyb3JzID09PSAwIHx8IGNtZE9iai5mb3JjZSA/IDAgOiAxKTtcbiAgICB9KTtcblxuICBwcm9ncmFtXG4gICAgLmNvbW1hbmQoJ3ZhbGlkYXRlIFtlbnRyeVBvaW50cy4uLl0nKVxuICAgIC5kZXNjcmlwdGlvbignVmFsaWRhdGUgZ2l2ZW4gT3BlbkFQSSAzIGRlZmluaXRpb24gZmlsZS4nKVxuICAgIC5vcHRpb24oJy0tc2hvcnQnLCAnUmVkdWNlIG91dHB1dCB0byByZXF1aXJlZCBtaW5pbXVuLicpXG4gICAgLm9wdGlvbignLS1uby1mcmFtZScsICdQcmludCBubyBjb2RlZnJhbWVzIHdpdGggZXJyb3JzLicpXG4gICAgLm9wdGlvbignLS1jb25maWcgPHBhdGg+JywgJ1NwZWNpZnkgY3VzdG9tIHlhbWwgb3IganNvbiBjb25maWcnKVxuICAgIC5hY3Rpb24oYXN5bmMgKGVudHJ5UG9pbnRzLCBjbWRPYmopID0+IHtcbiAgICAgIGNvbnN0IG9wdGlvbnMgPSB7fTtcbiAgICAgIGNvbnN0IHJlc3VsdHMgPSB7XG4gICAgICAgIGVycm9yczogMCxcbiAgICAgICAgd2FybmluZ3M6IDAsXG4gICAgICB9O1xuXG4gICAgICBjb25zdCBjb25maWcgPSBnZXRDb25maWcoe30pO1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG4gICAgICBlbnRyeVBvaW50cyA9IGdldEZhbGxiYWNrRW50cnlQb2ludHNPckV4aXQoZW50cnlQb2ludHMsIGNvbmZpZyk7XG5cbiAgICAgIG9wdGlvbnMuY29kZWZyYW1lcyA9IGNtZE9iai5mcmFtZTtcbiAgICAgIGlmIChjbWRPYmouY29uZmlnKSBvcHRpb25zLmNvbmZpZ1BhdGggPSBjbWRPYmouY29uZmlnO1xuXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGVudHJ5UG9pbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHByaW50VmFsaWRhdGlvbkhlYWRlcihlbnRyeVBvaW50c1tpXSk7XG5cbiAgICAgICAgY29uc3QgbXNncyA9IGF3YWl0IHZhbGlkYXRlRmlsZShlbnRyeVBvaW50c1tpXSwgb3B0aW9ucywgY21kT2JqKTtcbiAgICAgICAgcmVzdWx0cy5lcnJvcnMgKz0gbXNncy5lcnJvcnM7XG4gICAgICAgIHJlc3VsdHMud2FybmluZ3MgKz0gbXNncy53YXJuaW5ncztcbiAgICAgIH1cbiAgICAgIGlmIChlbnRyeVBvaW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgIHByb2Nlc3Muc3Rkb3V0LndyaXRlKGBWYWxpZGF0aW9uIHJlc3VsdHM6XFxuZXJyb3JzOiAke3Jlc3VsdHMuZXJyb3JzfVxcbndhcm5pbmdzOiAke3Jlc3VsdHMud2FybmluZ3N9XFxuYCk7XG4gICAgICB9XG4gICAgICBwcm9jZXNzLmV4aXQocmVzdWx0cy5lcnJvcnMgPiAwID8gMSA6IDApO1xuICAgIH0pO1xuXG4gIGZ1bmN0aW9uIG15UGFyc2VJbnQodmFsdWUpIHtcbiAgICByZXR1cm4gcGFyc2VJbnQodmFsdWUsIDEwKTtcbiAgfVxuXG4gIHByb2dyYW1cbiAgICAuY29tbWFuZCgncHJldmlldy1kb2NzIFtlbnRyeVBvaW50XScpXG4gICAgLmRlc2NyaXB0aW9uKCdQcmV2aWV3IEFQSSBSZWZlcmVuY2UgZG9jcyBmb3IgdGhlIHNwZWNpZmllZCBlbnRyeXBvaW50IE9BUyBkZWZpbml0aW9uJylcbiAgICAub3B0aW9uKCctcCwgLS1wb3J0IDx2YWx1ZT4nLCAnUHJldmlldyBwb3J0JywgbXlQYXJzZUludCwgODA4MClcbiAgICAub3B0aW9uKCctLXVzZS1jb21tdW5pdHktZWRpdGlvbicsICdVc2UgUmVkb2MgQ0UgZm9yIGRvY3MgcHJldmlldy4nKVxuICAgIC5hY3Rpb24oYXN5bmMgKGVudHJ5UG9pbnQsIGNtZE9iaikgPT4ge1xuICAgICAgY29uc3Qgb3V0cHV0ID0gJ2Rpc3Qvb3BlbmFwaS55YW1sJztcblxuICAgICAgbGV0IGNvbmZpZyA9IGdldENvbmZpZyh7fSk7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcGFyYW0tcmVhc3NpZ24sIHByZWZlci1kZXN0cnVjdHVyaW5nXG4gICAgICBlbnRyeVBvaW50ID0gZ2V0RmFsbGJhY2tFbnRyeVBvaW50c09yRXhpdChlbnRyeVBvaW50ID8gW2VudHJ5UG9pbnRdIDogW10sIGNvbmZpZylbMF07XG5cbiAgICAgIGxldCBjYWNoZWRCdW5kbGU7XG4gICAgICBjb25zdCBkZXBzID0gbmV3IFNldCgpO1xuXG4gICAgICBhc3luYyBmdW5jdGlvbiBnZXRCdW5kbGUoKSB7XG4gICAgICAgIHJldHVybiBjYWNoZWRCdW5kbGU7XG4gICAgICB9XG5cbiAgICAgIGFzeW5jIGZ1bmN0aW9uIHVwZGF0ZUJ1bmRsZSgpIHtcbiAgICAgICAgcHJvY2Vzcy5zdGRvdXQud3JpdGUoJ1xcbkJ1bmRsaW5nLi4uXFxuXFxuJyk7XG4gICAgICAgIGNvbnN0IHsgYnVuZGxlOiBvcGVuYXBpQnVuZGxlLCByZXN1bHQsIGZpbGVEZXBlbmRlbmNpZXMgfSA9IGF3YWl0IGJ1bmRsZShlbnRyeVBvaW50LCBvdXRwdXQsIHtcbiAgICAgICAgICBsaW50OiB7XG4gICAgICAgICAgICBjb2RlZnJhbWVzOiBmYWxzZSxcbiAgICAgICAgICB9LFxuICAgICAgICB9KTtcblxuICAgICAgICBjb25zdCByZW1vdmVkID0gWy4uLmRlcHNdLmZpbHRlcigoeCkgPT4gIWZpbGVEZXBlbmRlbmNpZXMuaGFzKHgpKTtcbiAgICAgICAgd2F0Y2hlci51bndhdGNoKHJlbW92ZWQpO1xuICAgICAgICB3YXRjaGVyLmFkZChbLi4uZmlsZURlcGVuZGVuY2llc10pO1xuICAgICAgICBkZXBzLmNsZWFyKCk7XG4gICAgICAgIGZpbGVEZXBlbmRlbmNpZXMuZm9yRWFjaChkZXBzLmFkZCwgZGVwcyk7XG5cbiAgICAgICAgY29uc3QgcmVzdWx0U3RhdHMgPSBvdXRwdXRNZXNzYWdlcyhyZXN1bHQsIHsgc2hvcnQ6IHRydWUgfSk7XG5cbiAgICAgICAgaWYgKHJlc3VsdFN0YXRzLnRvdGFsRXJyb3JzID09PSAwKSB7XG4gICAgICAgICAgcHJvY2Vzcy5zdGRvdXQud3JpdGUoXG4gICAgICAgICAgICByZXN1bHRTdGF0cy50b3RhbEVycm9ycyA9PT0gMFxuICAgICAgICAgICAgICA/IGBDcmVhdGVkIGEgYnVuZGxlIGZvciAke2VudHJ5UG9pbnR9ICR7cmVzdWx0U3RhdHMudG90YWxXYXJuaW5ncyA+IDAgPyAnd2l0aCB3YXJuaW5ncycgOiAnc3VjY2Vzc2Z1bGx5J31cXG5gXG4gICAgICAgICAgICAgIDogY2hhbGsueWVsbG93KGBDcmVhdGVkIGEgYnVuZGxlIGZvciAke2VudHJ5UG9pbnR9IHdpdGggZXJyb3JzLiBEb2NzIG1heSBiZSBicm9rZW4gb3Igbm90IGFjY3VyYXRlXFxuYCksXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBvcGVuYXBpQnVuZGxlO1xuICAgICAgfVxuXG4gICAgICBjb25zdCByZWRvY2x5Q2xpZW50ID0gbmV3IFJlZG9jbHlDbGllbnQoKTtcbiAgICAgIGNvbnN0IGlzQXV0aG9yaXplZFdpdGhSZWRvY2x5ID0gYXdhaXQgcmVkb2NseUNsaWVudC5pc0F1dGhvcml6ZWRXaXRoUmVkb2NseSgpO1xuXG4gICAgICBzZXRJbW1lZGlhdGUoKCkgPT4ge1xuICAgICAgICBjYWNoZWRCdW5kbGUgPSB1cGRhdGVCdW5kbGUoKTtcbiAgICAgIH0pOyAvLyBpbml0aWFsIGNhY2hlXG5cbiAgICAgIGNvbnN0IHJlZmVyZW5jZURvY3MgPSBjb25maWcucmVmZXJlbmNlRG9jcyB8fCB7fTtcblxuICAgICAgY29uc3QgcmVkb2NPcHRpb25zID0ge1xuICAgICAgICAuLi5yZWZlcmVuY2VEb2NzLFxuICAgICAgICB1c2VDb21tdW5pdHlFZGl0aW9uOiBjbWRPYmoudXNlQ29tbXVuaXR5RWRpdGlvbiB8fCByZWZlcmVuY2VEb2NzLnVzZUNvbW11bml0eUVkaXRpb24sXG4gICAgICAgIGxpY2Vuc2VLZXk6IHByb2Nlc3MuZW52LlJFRE9DTFlfTElDRU5TRV9LRVkgfHwgcmVmZXJlbmNlRG9jcy5saWNlbnNlS2V5LFxuICAgICAgfTtcblxuICAgICAgY29uc3QgaG90Q2xpZW50cyA9IGF3YWl0IHN0YXJ0UHJldmlld1NlcnZlcihjbWRPYmoucG9ydCwge1xuICAgICAgICBnZXRCdW5kbGUsXG4gICAgICAgIGdldE9wdGlvbnM6ICgpID0+IHJlZG9jT3B0aW9ucyxcbiAgICAgICAgdXNlUmVkb2NQcm86IChpc0F1dGhvcml6ZWRXaXRoUmVkb2NseSB8fCByZWRvY09wdGlvbnMubGljZW5zZUtleSkgJiYgIXJlZG9jT3B0aW9ucy51c2VDb21tdW5pdHlFZGl0aW9uLFxuICAgICAgfSk7XG5cbiAgICAgIGNvbnN0IHdhdGNoZXIgPSBjaG9ja2lkYXIud2F0Y2goW2VudHJ5UG9pbnQsIGNvbmZpZy5jb25maWdQYXRoXSwge1xuICAgICAgICBkaXNhYmxlR2xvYmJpbmc6IHRydWUsXG4gICAgICAgIGlnbm9yZUluaXRpYWw6IHRydWUsXG4gICAgICB9KTtcblxuICAgICAgY29uc3QgZGVib3VuY2VkVXBkYXRlZGVCdW5kbGUgPSBkZWJvdW5jZShhc3luYyAoKSA9PiB7XG4gICAgICAgIGNhY2hlZEJ1bmRsZSA9IHVwZGF0ZUJ1bmRsZSgpO1xuICAgICAgICBhd2FpdCBjYWNoZWRCdW5kbGU7XG4gICAgICAgIGhvdENsaWVudHMuYnJvYWRjYXN0KCd7XCJ0eXBlXCI6IFwicmVsb2FkXCIsIFwiYnVuZGxlXCI6IHRydWV9Jyk7XG4gICAgICB9LCAyMDAwKTtcblxuICAgICAgY29uc3QgY2hhbmdlSGFuZGxlciA9IGFzeW5jICh0eXBlLCBmaWxlKSA9PiB7XG4gICAgICAgIHByb2Nlc3Muc3Rkb3V0LndyaXRlKGAke2NoYWxrLmdyZWVuKCd3YXRjaCcpfSAke3R5cGV9ICR7Y2hhbGsuYmx1ZShmaWxlKX1cXG5gKTtcbiAgICAgICAgaWYgKGZpbGUgPT09IGNvbmZpZy5jb25maWdQYXRoKSB7XG4gICAgICAgICAgY29uZmlnID0gZ2V0Q29uZmlnKHsgY29uZmlnUGF0aDogZmlsZSB9KTtcbiAgICAgICAgICBob3RDbGllbnRzLmJyb2FkY2FzdChKU09OLnN0cmluZ2lmeSh7IHR5cGU6ICdyZWxvYWQnIH0pKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBkZWJvdW5jZWRVcGRhdGVkZUJ1bmRsZSgpO1xuICAgICAgfTtcblxuICAgICAgd2F0Y2hlci5vbignY2hhbmdlJywgY2hhbmdlSGFuZGxlci5iaW5kKHVuZGVmaW5lZCwgJ2NoYW5nZWQnKSk7XG4gICAgICB3YXRjaGVyLm9uKCdhZGQnLCBjaGFuZ2VIYW5kbGVyLmJpbmQodW5kZWZpbmVkLCAnYWRkZWQnKSk7XG4gICAgICB3YXRjaGVyLm9uKCd1bmxpbmsnLCBjaGFuZ2VIYW5kbGVyLmJpbmQodW5kZWZpbmVkLCAncmVtb3ZlZCcpKTtcblxuICAgICAgd2F0Y2hlci5vbigncmVhZHknLCAoKSA9PiB7XG4gICAgICAgIHByb2Nlc3Muc3Rkb3V0LndyaXRlKGBcXG4gIPCfkYAgIFdhdGNoaW5nICR7Y2hhbGsuYmx1ZShlbnRyeVBvaW50KX0gYW5kIGFsbCByZWxhdGVkIHJlc291cmNlcyBmb3IgY2hhbmdlc1xcbmApO1xuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgcHJvZ3JhbS5vbignY29tbWFuZDoqJywgKCkgPT4ge1xuICAgIHByb2Nlc3Muc3RkZXJyLndyaXRlKGBcXG5Vbmtub3duIGNvbW1hbmQgJHtwcm9ncmFtLmFyZ3Muam9pbignICcpfVxcblxcbmApO1xuICAgIHByb2dyYW0ub3V0cHV0SGVscCgpO1xuICB9KTtcblxuICBpZiAocHJvY2Vzcy5hcmd2Lmxlbmd0aCA9PT0gMikgcHJvY2Vzcy5hcmd2LnB1c2goJy1oJyk7XG5cbiAgcHJvZ3JhbS5wYXJzZShwcm9jZXNzLmFyZ3YpO1xufTtcblxuZXhwb3J0IGRlZmF1bHQgY2xpO1xuIl19